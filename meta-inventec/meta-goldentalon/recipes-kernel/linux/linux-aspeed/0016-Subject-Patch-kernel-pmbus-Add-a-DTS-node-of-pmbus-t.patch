From f3b35f4dd756f2ec35b3f853732a1fa4686b4451 Mon Sep 17 00:00:00 2001
From: anonymous <anonymous@inventec.com>
Date: Thu, 3 Sep 2020 18:09:29 -0400
Subject: [PATCH 16/21] Subject: [Patch][kernel][pmbus] Add a DTS node of pmbus
 to use fixed fan_config date

- Add a DTS node of pmbus to use fixed fan_config date.
  Due to some PSUs support fan but the FAN_CONFIG_1_2 (0x3A) and FAN_CONFIG_3_4 (0x3D) may not support,
  e.g. P2000 Series PSU.
---
 arch/arm/boot/dts/aspeed-bmc-microsoft-goldentalon.dts |  6 ++
 drivers/hwmon/pmbus/pmbus.c                        | 11 ++-
 drivers/hwmon/pmbus/pmbus_core.c                   | 80 ++++++++++++++++++----
 3 files changed, 80 insertions(+), 17 deletions(-)

diff --git a/arch/arm/boot/dts/aspeed-bmc-microsoft-goldentalon.dts b/arch/arm/boot/dts/aspeed-bmc-microsoft-goldentalon.dts
index 90c9957..187fcd7 100644
--- a/arch/arm/boot/dts/aspeed-bmc-microsoft-goldentalon.dts
+++ b/arch/arm/boot/dts/aspeed-bmc-microsoft-goldentalon.dts
@@ -355,6 +355,12 @@
 	psu0:psu0@58 {
 		compatible = "pmbus";
 		reg = <0x58>;
+		/* Due to some PSUs support fan
+		   but the FAN_CONFIG_1_2 (0x3A) and FAN_CONFIG_3_4 (0x3D) may not support
+		   e.g. P2000 Series PSU. So add a node to set fan_config value.
+		*/
+		// set fan_1_2 installed and duty cycle mode; fan_3_4 uninstalled
+		fan_configs = /bits/ 8 <0x88 0x00>;
 	};
 };
 
diff --git a/drivers/hwmon/pmbus/pmbus.c b/drivers/hwmon/pmbus/pmbus.c
index d10c957..8ed6c33 100644
--- a/drivers/hwmon/pmbus/pmbus.c
+++ b/drivers/hwmon/pmbus/pmbus.c
@@ -40,13 +40,20 @@ static void pmbus_find_sensor_groups(struct i2c_client *client,
 	if (info->func[0]
 	    && pmbus_check_byte_register(client, 0, PMBUS_STATUS_INPUT))
 		info->func[0] |= PMBUS_HAVE_STATUS_INPUT;
-	if (pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_12) &&
+
+	/*
+	 * Due to some PSUs support fan but the FAN_CONFIG_1_2 (0x3A) and FAN_CONFIG_3_4 (0x3D) may not support
+	 * e.g. P2000 Series PSU.
+	 * And the pmbus_add_fan_attributes function will check this value again.
+	 * So here we just check if it can support PMBUS_READ_FAN_SPEED
+	*/
+	if (/* pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_12) && */
 	    pmbus_check_word_register(client, 0, PMBUS_READ_FAN_SPEED_1)) {
 		info->func[0] |= PMBUS_HAVE_FAN12;
 		if (pmbus_check_byte_register(client, 0, PMBUS_STATUS_FAN_12))
 			info->func[0] |= PMBUS_HAVE_STATUS_FAN12;
 	}
-	if (pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_34) &&
+	if (/* pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_34) && */
 	    pmbus_check_word_register(client, 0, PMBUS_READ_FAN_SPEED_3)) {
 		info->func[0] |= PMBUS_HAVE_FAN34;
 		if (pmbus_check_byte_register(client, 0, PMBUS_STATUS_FAN_34))
diff --git a/drivers/hwmon/pmbus/pmbus_core.c b/drivers/hwmon/pmbus/pmbus_core.c
index 82ffe0a..627f7ad 100644
--- a/drivers/hwmon/pmbus/pmbus_core.c
+++ b/drivers/hwmon/pmbus/pmbus_core.c
@@ -110,6 +110,13 @@ struct pmbus_data {
 
 	s16 currpage;	/* current page, -1 for unknown/unset */
 	s16 currphase;	/* current phase, 0xff for all, -1 for unknown/unset */
+
+	/*
+	 * fixed fan_config value
+	 * Due to some PSUs support fan but the FAN_CONFIG_1_2 (0x3A) and FAN_CONFIG_3_4 (0x3D) may not support
+	 * e.g. P2000 Series PSU. So if the dts has the node fan_configs then this pointer will be used.
+	*/
+	u8 *fan_configs;
 };
 
 struct pmbus_debugfs_entry {
@@ -287,18 +294,22 @@ int pmbus_update_fan(struct i2c_client *client, int page, int id,
 	int from;
 	int rv;
 	u8 to;
+	struct pmbus_data *data = i2c_get_clientdata(client);
 
-	from = pmbus_read_byte_data(client, page,
-				    pmbus_fan_config_registers[id]);
-	if (from < 0)
-		return from;
-
-	to = (from & ~mask) | (config & mask);
-	if (to != from) {
-		rv = pmbus_write_byte_data(client, page,
-					   pmbus_fan_config_registers[id], to);
-		if (rv < 0)
-			return rv;
+	// check if we use fixed fan_config data
+	if (!data->fan_configs) {
+		from = pmbus_read_byte_data(client, page,
+						pmbus_fan_config_registers[id]);
+		if (from < 0)
+			return from;
+
+		to = (from & ~mask) | (config & mask);
+		if (to != from) {
+			rv = pmbus_write_byte_data(client, page,
+						pmbus_fan_config_registers[id], to);
+			if (rv < 0)
+				return rv;
+		}
 	}
 
 	return _pmbus_write_word_data(client, page,
@@ -460,8 +471,14 @@ static int pmbus_get_fan_rate(struct i2c_client *client, int page, int id,
 		return s->data;
 	}
 
-	config = _pmbus_read_byte_data(client, page,
-				       pmbus_fan_config_registers[id]);
+	// check if we use fixed fan_config data
+	if (data->fan_configs) {
+		config = data->fan_configs[id];
+	} else {
+		config = _pmbus_read_byte_data(client, page,
+						pmbus_fan_config_registers[id]);
+	}
+
 	if (config < 0)
 		return config;
 
@@ -1936,8 +1953,14 @@ static int pmbus_add_fan_attributes(struct i2c_client *client,
 			 * Each fan configuration register covers multiple fans,
 			 * so we have to do some magic.
 			 */
-			regval = _pmbus_read_byte_data(client, page,
-				pmbus_fan_config_registers[f]);
+			// check if we use fixed fan_config data
+			if (data->fan_configs) {
+				regval = data->fan_configs[f];
+			} else {
+				regval = _pmbus_read_byte_data(client, page,
+					pmbus_fan_config_registers[f]);
+			}
+
 			if (regval < 0 ||
 			    (!(regval & (PB_FAN_1_INSTALLED >> ((f & 1) * 4)))))
 				continue;
@@ -2575,6 +2598,7 @@ int pmbus_do_probe(struct i2c_client *client, const struct i2c_device_id *id,
 	struct pmbus_data *data;
 	size_t groups_num = 0;
 	int ret;
+	u8 fan_configs[2] = {0}; // currently only consider fan_config_1_2 and fan_config_3_4
 
 	if (!info)
 		return -ENODEV;
@@ -2607,6 +2631,26 @@ int pmbus_do_probe(struct i2c_client *client, const struct i2c_device_id *id,
 	data->currpage = -1;
 	data->currphase = -1;
 
+
+	ret = of_property_read_u8_array(dev->of_node, "fan_configs",
+					fan_configs, ARRAY_SIZE(fan_configs));
+
+	if (!ret) {
+		data->fan_configs = devm_kzalloc(dev,
+						ARRAY_SIZE(pmbus_fan_config_registers),
+						GFP_KERNEL);
+		if (data->fan_configs) {
+			dev_info(dev,
+				"Use fixed fan_configs, fan_config_1_2 :0x%x, fan_config_3_4 :0x%x\n",
+				fan_configs[0], fan_configs[1]);
+			// currently only consider fan_config_1_2 and fan_config_3_4
+			data->fan_configs[0] = fan_configs[0];
+			data->fan_configs[1] = fan_configs[0];
+			data->fan_configs[2] = fan_configs[1];
+			data->fan_configs[3] = fan_configs[1];
+		}
+	}
+
 	ret = pmbus_init_common(client, data, info);
 	if (ret < 0)
 		return ret;
@@ -2649,6 +2693,9 @@ int pmbus_do_probe(struct i2c_client *client, const struct i2c_device_id *id,
 	hwmon_device_unregister(data->hwmon_dev);
 out_kfree:
 	kfree(data->group.attrs);
+	if (data->fan_configs) {
+		kfree(data->fan_configs);
+	}
 	return ret;
 }
 EXPORT_SYMBOL_GPL(pmbus_do_probe);
@@ -2661,6 +2708,9 @@ int pmbus_do_remove(struct i2c_client *client)
 
 	hwmon_device_unregister(data->hwmon_dev);
 	kfree(data->group.attrs);
+	if (data->fan_configs) {
+		kfree(data->fan_configs);
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pmbus_do_remove);
-- 
2.7.4

