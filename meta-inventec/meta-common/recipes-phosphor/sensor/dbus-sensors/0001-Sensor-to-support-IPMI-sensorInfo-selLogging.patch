From 6da16a8d104c9bd740247a85fa93c4a6868c39ba Mon Sep 17 00:00:00 2001
From: anonymous <anonymous@inventec.com>
Date: Thu, 13 Aug 2020 15:46:36 -0400
Subject: [PATCH 01/13] Subject: [PATCH] Subject: [PATCH][Sensor] Patch to
 support IPMI sensor info and add IPMI sel

- Support retrieving IPMI information from entity-manager inventory
- Add the dbus-interface definitions of IPMI logging service in Utils.hpp for recording IPMI SEL.
- Add a hook function in the setupPowerMatch function.
---
 CMakeLists.txt       | 19 ++++++------
 include/IpmiInfo.hpp | 33 ++++++++++++++++++++
 include/Utils.hpp    | 12 ++++++++
 include/sensor.hpp   |  7 +++++
 src/IpmiInfo.cpp     | 86 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/Utils.cpp        | 13 ++++++++
 6 files changed, 161 insertions(+), 9 deletions(-)
 create mode 100644 include/IpmiInfo.hpp
 create mode 100644 src/IpmiInfo.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2715c4e..3e0a7c0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -54,28 +54,29 @@ huntergate (URL "https://github.com/ruslo/hunter/archive/v0.18.64.tar.gz" SHA1
 
 project (sensors CXX)
 
-set (ADC_SRC_FILES src/Utils.cpp src/ADCSensor.cpp src/Thresholds.cpp)
+set (ADC_SRC_FILES src/Utils.cpp src/ADCSensor.cpp src/Thresholds.cpp src/IpmiInfo.cpp)
 
-set (CPU_SRC_FILES src/Utils.cpp src/CPUSensor.cpp src/Thresholds.cpp)
+set (CPU_SRC_FILES src/Utils.cpp src/CPUSensor.cpp src/Thresholds.cpp src/IpmiInfo.cpp)
 
-set (EXIT_AIR_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
+set (EXIT_AIR_SRC_FILES src/Utils.cpp src/Thresholds.cpp src/IpmiInfo.cpp)
 
 set (FAN_SRC_FILES src/TachSensor.cpp src/PwmSensor.cpp src/Utils.cpp
-     src/Thresholds.cpp)
+     src/Thresholds.cpp src/IpmiInfo.cpp)
 
 set (HWMON_TEMP_SRC_FILES src/Utils.cpp src/HwmonTempSensor.cpp
-     src/Thresholds.cpp)
+     src/Thresholds.cpp src/IpmiInfo.cpp)
 
 set (INTRUSION_SRC_FILES src/Utils.cpp src/ChassisIntrusionSensor.cpp)
 
-set (IPMB_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
+set (IPMB_SRC_FILES src/Utils.cpp src/Thresholds.cpp src/IpmiInfo.cpp)
 
-set (MCUTEMP_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
+set (MCUTEMP_SRC_FILES src/Utils.cpp src/Thresholds.cpp src/IpmiInfo.cpp)
 
 set (PSU_SRC_FILES src/Utils.cpp src/PSUSensor.cpp src/Thresholds.cpp
-     src/PwmSensor.cpp src/PSUEvent.cpp)
+     src/PwmSensor.cpp src/PSUEvent.cpp src/IpmiInfo.cpp)
 
-set (NVME_SRC_FILES src/Utils.cpp src/NVMeSensorMain.cpp src/NVMeSensor.cpp src/Thresholds.cpp)
+set (NVME_SRC_FILES src/Utils.cpp src/NVMeSensorMain.cpp src/NVMeSensor.cpp
+     src/Thresholds.cpp src/IpmiInfo.cpp)
 
 set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
 set (SENSOR_LINK_LIBS -lsystemd stdc++fs sdbusplus)
diff --git a/include/IpmiInfo.hpp b/include/IpmiInfo.hpp
new file mode 100644
index 0000000..68d29cb
--- /dev/null
+++ b/include/IpmiInfo.hpp
@@ -0,0 +1,33 @@
+#pragma once
+#include "Utils.hpp"
+
+#include <boost/asio/io_service.hpp>
+#include <list>
+#include <memory>
+#include <nlohmann/json.hpp>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace ipmidata
+{
+
+struct IpmiConfig
+{
+    IpmiConfig(const uint64_t num, 
+               const uint64_t id, 
+               const uint64_t ins) :
+              number(num), entityId(id), entityIns(ins)
+    {
+    }
+    uint64_t number;
+    uint64_t entityId;
+    uint64_t entityIns;
+};
+
+bool parseIpmiDataFromConfig(
+    const SensorData& sensorData,
+    std::vector<ipmidata::IpmiConfig>& ipmiVector,
+    std::string* matchLabel = nullptr);
+
+} // namespace ipmidata
diff --git a/include/Utils.hpp b/include/Utils.hpp
index c164187..5b511f0 100644
--- a/include/Utils.hpp
+++ b/include/Utils.hpp
@@ -68,6 +68,10 @@ void createAssociation(
 void findLimits(std::pair<double, double>& limits,
                 const SensorBaseConfiguration* data);
 
+// to setup a hook function pointer which can be used to do some action immediately once recieve dbus signal of power status match
+void setupPowerStatHookHandlr(std::function<void(bool)> hookHandlr);
+
+
 enum class PowerState
 {
     on,
@@ -75,6 +79,14 @@ enum class PowerState
     always
 };
 
+namespace sel
+{
+const static constexpr char* service = "xyz.openbmc_project.Logging.IPMI";
+const static constexpr char* interface = "xyz.openbmc_project.Logging.IPMI";
+const static constexpr char* path = "/xyz/openbmc_project/Logging/IPMI";
+const static constexpr char* addsel = "IpmiSelAdd";
+} // namespace sel
+
 namespace mapper
 {
 constexpr const char* busName = "xyz.openbmc_project.ObjectMapper";
diff --git a/include/sensor.hpp b/include/sensor.hpp
index 0ef87d5..1cd66b7 100644
--- a/include/sensor.hpp
+++ b/include/sensor.hpp
@@ -2,6 +2,7 @@
 
 #include "Thresholds.hpp"
 #include "Utils.hpp"
+#include "IpmiInfo.hpp"
 
 #include <sdbusplus/asio/object_server.hpp>
 
@@ -61,6 +62,7 @@ struct Sensor
     double minValue;
     std::vector<thresholds::Threshold> thresholds;
     std::shared_ptr<sdbusplus::asio::dbus_interface> sensorInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> ipmiInterface;
     std::shared_ptr<sdbusplus::asio::dbus_interface> thresholdInterfaceWarning;
     std::shared_ptr<sdbusplus::asio::dbus_interface> thresholdInterfaceCritical;
     std::shared_ptr<sdbusplus::asio::dbus_interface> association;
@@ -312,6 +314,11 @@ struct Sensor
             operationalInterface->register_property("Functional", true);
             operationalInterface->initialize();
         }
+
+        if (ipmiInterface && !ipmiInterface->initialize())
+        {
+            std::cerr << "error initializing ipmi interface\n";
+        }
     }
 
     bool readingStateGood()
diff --git a/src/IpmiInfo.cpp b/src/IpmiInfo.cpp
new file mode 100644
index 0000000..4187f68
--- /dev/null
+++ b/src/IpmiInfo.cpp
@@ -0,0 +1,86 @@
+#include "IpmiInfo.hpp"
+
+#include "VariantVisitors.hpp"
+#include "sensor.hpp"
+
+#include <array>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_map.hpp>
+#include <boost/lexical_cast.hpp>
+#include <cmath>
+
+#include <fstream>
+#include <iostream>
+#include <stdexcept>
+#include <string>
+#include <utility>
+#include <variant>
+#include <vector>
+
+static constexpr bool DEBUG = false;
+
+namespace ipmidata
+{
+
+bool parseIpmiDataFromConfig(
+    const SensorData& sensorData,
+    std::vector<ipmidata::IpmiConfig>& ipmiVector,
+    std::string* matchLabel)
+{
+
+    for (const auto& item : sensorData)
+    {
+        if constexpr (DEBUG)
+        {
+            std::cout << "parseIpmiDataFromConfig " << *matchLabel  << "\n";
+        }
+
+        if (item.first.find("SensorInfo") == std::string::npos)
+        {
+            continue;
+        }
+
+        if (matchLabel != nullptr)
+        {
+            auto labelFind = item.second.find("Label");
+            if (labelFind == item.second.end())
+                continue;
+
+            if constexpr (DEBUG)
+            {
+                std::cout << "Label: " << std::visit(VariantToStringVisitor(), labelFind->second) << " NAME: " << *matchLabel << "\n";
+            }
+
+            if (std::visit(VariantToStringVisitor(), labelFind->second) !=
+                *matchLabel)
+                continue;
+        }
+
+        auto configurationSN = item.second.find("SensorNum");
+        auto configurationEID = item.second.find("EntityId");
+        auto configurationEIS = item.second.find("EntityInstance");
+        if (configurationSN == item.second.end() ||
+            configurationEID == item.second.end() ||
+            configurationEIS == item.second.end())
+        {
+            std::cout << "Missing ipmi data in configuration\n";
+            return false;
+        }
+
+        uint64_t sn =  std::visit(VariantToUnsignedIntVisitor(), configurationSN->second);
+        uint64_t id =  std::visit(VariantToUnsignedIntVisitor(), configurationEID->second);
+        uint64_t is =  std::visit(VariantToUnsignedIntVisitor(), configurationEIS->second);
+
+        if constexpr (DEBUG)
+        {
+            std::cerr << "SN: "  << sn << " "
+                      << "EID: " << id << " "
+                      << "EIS: " << is << "\n";
+        }
+        ipmiVector.emplace_back(sn, id, is);
+        return true; // Get match IPMI info and then return
+    }
+    return true;
+}
+
+} // namespace ipmidata
diff --git a/src/Utils.cpp b/src/Utils.cpp
index 899ec98..03609e0 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -125,6 +125,17 @@ std::set<std::string> getPermitSet(const SensorBaseConfigMap& config)
         }
     }
     return permitSet;
+// Define a hook function pointer which can be used to do some action immediately once recieve dbus signal of power status match
+static std::function<void(bool)> powerStatHookHandlr = [] (bool powerStatus) {};
+void setupPowerStatHookHandlr(std::function<void(bool)> hookHandlr)
+{
+    // this a global function for this sensor monitor service, so only need setup at first time
+    static bool set = false;
+    if (!set)
+    {
+        powerStatHookHandlr = std::move(hookHandlr);
+        set = true;
+    }
 }
 
 bool getSensorConfiguration(
@@ -319,6 +330,7 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
                 {
                     timer.cancel();
                     powerStatusOn = false;
+                    powerStatHookHandlr(powerStatusOn);
                     return;
                 }
                 // on comes too quickly
@@ -334,6 +346,7 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
                         return;
                     }
                     powerStatusOn = true;
+                    powerStatHookHandlr(powerStatusOn);
                 });
             }
         });
-- 
2.7.4

