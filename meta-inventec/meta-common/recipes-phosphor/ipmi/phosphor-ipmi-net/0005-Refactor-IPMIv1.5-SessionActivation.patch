From 25e8ec95b00bb8bcb29fad6d7d492b8691632934 Mon Sep 17 00:00:00 2001
From: cwsun <sun.cwsun@inventec.com>
Date: Mon, 16 Aug 2021 13:40:49 +0800
Subject: [PATCH] [Transformers][SW] Refactor IPMI v1.5 Session Activation

    Symptom/Reason :
        - The parser if ipmi15::unflatten() maybe access invalid pointer

    Root Cause:
        - header->payLoadLength may access incorrect index when Authentication code is added into the payload

    Solution/Change:
        [phosphor-ipmi-net]
            - message_parser.hpp
                -- add a new SessionHeader2_t to hanle the payload when Authentication code is added.
            - message_parser.cpp
                - modify api ipmi15::unflatten() to use new SessionHeader2_t struct when Authentication code is added

    Entry Test:
        - Open RMCP(-Ilan) and RMCP+(lanplus) sessions with IPMI shell
          -- ipmitool -I lan -H myqemu -U root -P openbmc123 -p 2623
             > 01 80 00 00 02 9f a9 19 00 5b 00 00 00 00 00 7c

        - ipmitool by -I lan and by sendmessage command
          -- ipmitool -I lan -H 10.6.141.170 -p 623 -U root -P 0penBmc -b 6 -t 0x2c raw 0x06 0x01
             > 50 01 06 00 02 21 57 01 00 18 0b 06 12 10 01 91
---
 configure.ac         |  11 ----
 message_parsers.cpp  | 141 ++++++++++++++++++++++++++-----------------
 message_parsers.hpp  |   9 +++
 sessions_manager.cpp |   3 +-
 4 files changed, 94 insertions(+), 70 deletions(-)

diff --git a/configure.ac b/configure.ac
index 8e8ad57..36b0df4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -66,17 +66,6 @@ AS_IF([test "x$with_systemdsystemunitdir" != "xno"],
       [AC_SUBST([systemdsystemunitdir], [$with_systemdsystemunitdir])])
 AM_CONDITIONAL([HAVE_SYSTEMD], [test "x$with_systemdsystemunitdir" != "xno"])
 
-AC_ARG_ENABLE([rmcp-ping],
-        AS_HELP_STRING([--enable-rmcp-ping], [Enable RMCP Ping support])
-    )
-    AS_IF([test "x$enable_rmcp_ping" == "xyes"],
-        AC_MSG_NOTICE([Enabling RMCP Ping])
-        [
-            cpp_flags="-DRMCP_PING"
-        ]
-        AC_SUBST([CPPFLAGS], [$cpp_flags])
-)
-
 # Checks for header files.
 AC_CHECK_HEADER(systemd/sd-bus.h, ,[AC_MSG_ERROR([Could not find systemd/sd-bus.h...systemd development package required])])
 
diff --git a/message_parsers.cpp b/message_parsers.cpp
index 3c6898c..d02cee4 100644
--- a/message_parsers.cpp
+++ b/message_parsers.cpp
@@ -100,14 +100,17 @@ namespace ipmi15parser
 {
 
 uint8_t const AUTH_CODE_LENGTH = 16;
+uint8_t const SEQUENCENUM_LENGTH = 4;
+uint8_t const SESSIONID_LENGTH = 4;
 
 std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
 {
     struct AuthCode_t authCode;
     std::shared_ptr<Session> session(nullptr);
-    SessionHeader_t* header = nullptr;
 
-    if (inPacket.size() < sizeof(SessionHeader_t))
+    // 4bytes_RMCP + (1+4+4+1)bytes_IPMIHeader
+    const uint32_t SESSION_HEADER_SIZE = 14;
+    if (inPacket.size() < SESSION_HEADER_SIZE)
     {
         log<level::ERR>("IPMI1.5 Session Header Missing");
         throw std::runtime_error("IPMI1.5 Session Header Missing");
@@ -121,14 +124,15 @@ std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
     {
         //it has authCode
         uint8_t *start = inPacket.data();
-        header = reinterpret_cast<SessionHeader_t*>(inPacket.data());
+        auto header = reinterpret_cast<SessionHeader2_t*>(inPacket.data());
 
         memcpy(authCode.authCode,
-               start + sizeof(message::parser::BasicHeader_t) + 8,
-               ipmi15parser::AUTH_CODE_LENGTH);
-        
-        payloadLen = *(start+sizeof(message::parser::BasicHeader_t)+8+ipmi15parser::AUTH_CODE_LENGTH);
-        header->payloadLength = payloadLen;
+                start + sizeof(message::parser::BasicHeader_t) + 
+                    SEQUENCENUM_LENGTH + SESSIONID_LENGTH,
+                AUTH_CODE_LENGTH);
+
+        payloadLen = header->payloadLength;
+ 
         if (header->sessId != 0x00)
         {
             session = std::get<session::Manager&>(singletonPool)
@@ -137,8 +141,13 @@ std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
             session->authType = authType;
         }
 
+        message->bmcSessionID = endian::from_ipmi(header->sessId);
+        message->sessionSeqNum = endian::from_ipmi(header->sessSeqNum);
+        message->rmcpMsgClass =
+            static_cast<ClassOfMsg>(header->base.rmcp.classOfMsg);
+
     }else{
-        header = reinterpret_cast<SessionHeader_t*>(inPacket.data());
+        auto header = reinterpret_cast<SessionHeader_t*>(inPacket.data());
         payloadLen = header->payloadLength;
         if (header->sessId != 0x00)
         {
@@ -147,19 +156,20 @@ std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
             memcpy(session->authCode, authCode.authCode, sizeof(authCode));
             session->authType = authType;
         }
+        message->bmcSessionID = endian::from_ipmi(header->sessId);
+        message->sessionSeqNum = endian::from_ipmi(header->sessSeqNum);
+        message->rmcpMsgClass =
+            static_cast<ClassOfMsg>(header->base.rmcp.classOfMsg);
     }
     
     message->payloadType = PayloadType::IPMI;
-    message->bmcSessionID = endian::from_ipmi(header->sessId);
-    message->sessionSeqNum = endian::from_ipmi(header->sessSeqNum);
     message->isPacketEncrypted = false;
     message->isPacketAuthenticated = false;
-    message->rmcpMsgClass = static_cast<ClassOfMsg>(header->base.rmcp.classOfMsg);
 
 
     // Confirm the number of data bytes received correlates to
     // the packet length in the header
-    if (inPacket.size() < (sizeof(SessionHeader_t) + payloadLen))
+    if (inPacket.size() < (SESSION_HEADER_SIZE + payloadLen))
     {
         log<level::ERR>("Invalid data length");
         throw std::runtime_error("Invalid data length");
@@ -167,10 +177,8 @@ std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
 
     if(authType != 0x00){
         (message->payload)
-            .assign(inPacket.data() + sizeof(SessionHeader_t) +
-                        ipmi15parser::AUTH_CODE_LENGTH,
-                    inPacket.data() + sizeof(SessionHeader_t) +
-                        ipmi15parser::AUTH_CODE_LENGTH+ payloadLen);
+            .assign(inPacket.data() + sizeof(SessionHeader2_t),
+                      inPacket.data() + sizeof(SessionHeader2_t) + payloadLen);
     }else{
         (message->payload)
             .assign(inPacket.data() + sizeof(SessionHeader_t),
@@ -180,7 +188,7 @@ std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
     if(authType != 0x00){
         std::string passwd = ipmi::ipmiUserGetPassword(session->userName);
         auto retv = ipmi15authcode::compare_authcode(
-            authType, passwd, header->sessId, header->sessSeqNum,
+            authType, passwd, message->bmcSessionID, message->sessionSeqNum,
             message->payload.data(), message->payload.size(),
             authCode.authCode);
         if (retv != 0)
@@ -196,52 +204,71 @@ std::shared_ptr<Message> unflatten(std::vector<uint8_t>& inPacket)
 std::vector<uint8_t> flatten(std::shared_ptr<Message> outMessage,
                              std::shared_ptr<session::Session> session)
 {
-    std::vector<uint8_t> packet(sizeof(SessionHeader_t)-1); // git rid of "payloadlength" byte 
-    
-    // Insert Session Header into the Packet
-    auto header = reinterpret_cast<SessionHeader_t*>(packet.data());
-    header->base.rmcp.version = parser::RMCP_VERSION;
-    header->base.rmcp.reserved = 0x00;
-    header->base.rmcp.rmcpSeqNum = parser::RMCP_SEQ;
-    header->base.rmcp.classOfMsg = static_cast<uint8_t>(ClassOfMsg::IPMI);
-    header->base.format.formatType = static_cast<uint8_t>(parser::SessionHeader::IPMI15);
-    header->sessSeqNum = 0;
-    header->sessId = endian::to_ipmi(outMessage->rcSessionID);
-    if( header->sessId != 0x00 )
+    std::vector<uint8_t> packet;
+
+    auto sessionid = endian::to_ipmi(outMessage->rcSessionID);
+
+   
+    if (sessionid == 0x00
+        || (session != nullptr && session->authType == 0x00 ) )
+    {
+        // Insert Session Header into the Packet
+        packet.resize(sizeof(SessionHeader_t));
+        auto header = reinterpret_cast<SessionHeader_t*>(packet.data());
+        header->base.rmcp.version = parser::RMCP_VERSION;
+        header->base.rmcp.reserved = 0x00;
+        header->base.rmcp.rmcpSeqNum = parser::RMCP_SEQ;
+        header->base.rmcp.classOfMsg = static_cast<uint8_t>(ClassOfMsg::IPMI);
+        header->base.format.formatType =
+            static_cast<uint8_t>(parser::SessionHeader::IPMI15);
+        header->sessSeqNum = 0;
+        header->sessId = sessionid;
+        header->payloadLength =
+            static_cast<uint8_t>(outMessage->payload.size());
+    }else
     {
+        packet.resize(sizeof(SessionHeader2_t));
+        auto header = reinterpret_cast<SessionHeader2_t*>(packet.data());
+        header->base.rmcp.version = parser::RMCP_VERSION;
+        header->base.rmcp.reserved = 0x00;
+        header->base.rmcp.rmcpSeqNum = parser::RMCP_SEQ;
+        header->base.rmcp.classOfMsg = static_cast<uint8_t>(ClassOfMsg::IPMI);
+        header->base.format.formatType =
+            static_cast<uint8_t>(parser::SessionHeader::IPMI15);
+        header->sessSeqNum = 0;
+        header->sessId = sessionid;
         // get IPMI outbound sequence numbers
         auto sequenceNum = session->sequenceNums.get(false);
         header->sessSeqNum = endian::to_ipmi(sequenceNum);
-        if(session->authType != 0x00)
+        header->base.format.formatType =
+            static_cast<uint8_t>(session->authType);
+
+        std::string passwd = ipmi::ipmiUserGetPassword(session->userName);
+
+        auto retv = ipmi15authcode::generate_authcode(
+            session->authType, passwd, header->sessId, header->sessSeqNum,
+            outMessage->payload.data(), outMessage->payload.size(),
+            session->authCode);
+
+        if (retv > 0)
         {
-            header->base.format.formatType = static_cast<uint8_t>(session->authType);
-
-            std::string passwd = ipmi::ipmiUserGetPassword(session->userName);
-            
-            auto retv = ipmi15authcode::generate_authcode(
-                session->authType, passwd, header->sessId, header->sessSeqNum,
-                outMessage->payload.data(), outMessage->payload.size(), session->authCode);
-
-            
-            if (retv > 0)
-            {
-                log<level::ERR>("IPMI1.5 Response Authcode generation failed");
-                throw std::runtime_error("IPMI1.5 Response Authcode generation failed");
-            }
-
-            for(int i=0; i<16; i++)
-            {
-                packet.push_back(session->authCode[i]);
-            }
+            log<level::ERR>("IPMI1.5 Response Authcode generation failed");
+            throw std::runtime_error(
+                "IPMI1.5 Response Authcode generation failed");
         }
-        session->sequenceNums.increment();
-    }else{
-        header->sessSeqNum = 0x00;
-    }
 
-    // The length of IPMI Message header for the IPMI Message payload
-    packet.push_back(static_cast<uint8_t>(outMessage->payload.size()));
+        for (int i = 0; i < AUTH_CODE_LENGTH; i++)
+        {
+            header->authCode[i] = session->authCode[i];
+        }
+        // The length of IPMI Message header for the IPMI Message payload
+
+        header->payloadLength =
+            static_cast<uint8_t>(outMessage->payload.size()); //
+
+        session->sequenceNums.increment();
 
+    }
 
     // Insert the Payload into the Packet
     packet.insert(packet.end(), outMessage->payload.begin(),
@@ -252,7 +279,7 @@ std::vector<uint8_t> flatten(std::shared_ptr<Message> outMessage,
     auto trailer =
         reinterpret_cast<SessionTrailer_t*>(packet.data() + packet.size());
     trailer->legacyPad = 0x00;
-    
+
     return packet;
 }
 
diff --git a/message_parsers.hpp b/message_parsers.hpp
index 86871a6..7fe4049 100644
--- a/message_parsers.hpp
+++ b/message_parsers.hpp
@@ -120,6 +120,15 @@ struct SessionHeader_t
     uint8_t payloadLength;
 } __attribute__((packed));
 
+struct SessionHeader2_t
+{
+    struct parser::BasicHeader_t base;
+    uint32_t sessSeqNum;
+    uint32_t sessId;
+    uint8_t authCode[16];
+    uint8_t payloadLength;
+} __attribute__((packed));
+
 struct AuthCode_t
 {
     uint8_t authCode[16];
diff --git a/sessions_manager.cpp b/sessions_manager.cpp
index 6ec81db..e1611b3 100644
--- a/sessions_manager.cpp
+++ b/sessions_manager.cpp
@@ -154,7 +154,6 @@ std::shared_ptr<Session>
     }
 
     log<level::INFO>("No free RMCP sessions left");
-
     throw std::runtime_error("No free sessions left");
 }
 
@@ -246,7 +245,7 @@ std::shared_ptr<Session>
 
         sessionsMap.emplace(bmcSessionID, session);
         session->sessionHandle(sessionHandle);
-
+        
         return session;
     }
 
