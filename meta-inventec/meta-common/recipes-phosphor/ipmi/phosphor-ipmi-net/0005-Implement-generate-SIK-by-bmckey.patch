From 20490c348873210ec05ad2a7fa5c9a9c2825f273 Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Tue, 16 Nov 2021 13:00:45 +0800
Subject: [PATCH] Bug 634 - [SW][Transformers][OpenBMC][IPMI]Implement
 generating SIK by BMC Key

    Symptom/Reason :
        - implement the SIK generation with kgkey

    Root Cause:
        - None

    Solution/Change:
        [phosphor-ipmi-net]
            - add function of SIK generation with kgkey
                -- the kgkey is enabled when kgkey size is not zero and kgkey state is locked

    Entry Test:
        - set kg key as "helloworld"
            ipmitool raw 0x06 0x56 0x01 0x01 0x01 0x68 0x65 0x6c 0x6c 0x6f 0x77 0x6f 0x72 0x6c 0x64
        - lock kg key
            ipmitool raw 0x06 0x56 0x01 0x02 0x01
        - After set kg key and lock kgkey, build RMCP+ session with kgkey
            ipmitool -C17 -I lanplus -H 172.17.0.2 -p 2623 -U root -P 0penBmc -k helloworld shell
---
 auth_algo.cpp      |  32 +++++++++++++++
 auth_algo.hpp      |   9 ++++
 command/rakp34.cpp | 100 ++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 140 insertions(+), 1 deletion(-)

diff --git a/auth_algo.cpp b/auth_algo.cpp
index 4572831..0790f69 100644
--- a/auth_algo.cpp
+++ b/auth_algo.cpp
@@ -32,6 +32,22 @@ std::vector<uint8_t>
     return output;
 }
 
+std::vector<uint8_t>
+    AlgoSHA1::generateSIK(const std::vector<uint8_t>& input) const
+{
+    std::vector<uint8_t> output(SHA_DIGEST_LENGTH);
+    unsigned int mdLen = 0;
+
+    if (HMAC(EVP_sha1(), kgKey.data(), kgKey.size(), input.data(),
+             input.size(), output.data(), &mdLen) == NULL)
+    {
+        log<level::ERR>("Generate SIK failed");
+        output.resize(0);
+    }
+    
+    return output;
+}
+
 std::vector<uint8_t>
     AlgoSHA1::generateICV(const std::vector<uint8_t>& input) const
 {
@@ -49,6 +65,22 @@ std::vector<uint8_t>
     return output;
 }
 
+std::vector<uint8_t>
+    AlgoSHA256::generateSIK(const std::vector<uint8_t>& input) const
+{
+    std::vector<uint8_t> output(SHA256_DIGEST_LENGTH);
+    unsigned int mdLen = 0;
+
+    if (HMAC(EVP_sha256(), kgKey.data(), kgKey.size(), input.data(),
+             input.size(), output.data(), &mdLen) == NULL)
+    {
+        log<level::ERR>("Generate HMAC_SHA256 failed");
+        output.resize(0);
+    }
+
+    return output;
+}
+
 std::vector<uint8_t>
     AlgoSHA256::generateHMAC(const std::vector<uint8_t>& input) const
 {
diff --git a/auth_algo.hpp b/auth_algo.hpp
index 894a853..ca97018 100644
--- a/auth_algo.hpp
+++ b/auth_algo.hpp
@@ -81,6 +81,8 @@ class Interface
     std::vector<uint8_t> virtual generateHMAC(
         const std::vector<uint8_t>& input) const = 0;
 
+    std::vector<uint8_t> virtual generateSIK(
+        const std::vector<uint8_t>& input) const = 0;
     /**
      * @brief Generate the Integrity Check Value
      *
@@ -120,6 +122,7 @@ class Interface
     // User Key is hardcoded to PASSW0RD till the IPMI User account
     // management is in place.
     std::array<uint8_t, USER_KEY_MAX_LENGTH> userKey = {"0penBmc"};
+    std::array<uint8_t, USER_KEY_MAX_LENGTH> kgKey = {"0123456789"};
 
     // Managed System Random Number
     std::array<uint8_t, BMC_RANDOM_NUMBER_LEN> bmcRandomNum;
@@ -180,6 +183,9 @@ class AlgoSHA1 : public Interface
     std::vector<uint8_t>
         generateHMAC(const std::vector<uint8_t>& input) const override;
 
+    std::vector<uint8_t>
+        generateSIK(const std::vector<uint8_t>& input) const override;
+
     std::vector<uint8_t>
         generateICV(const std::vector<uint8_t>& input) const override;
 };
@@ -215,6 +221,9 @@ class AlgoSHA256 : public Interface
     std::vector<uint8_t>
         generateHMAC(const std::vector<uint8_t>& input) const override;
 
+    std::vector<uint8_t>
+        generateSIK(const std::vector<uint8_t>& input) const override;
+
     std::vector<uint8_t>
         generateICV(const std::vector<uint8_t>& input) const override;
 };
diff --git a/command/rakp34.cpp b/command/rakp34.cpp
index b106b6f..f6ae4ed 100644
--- a/command/rakp34.cpp
+++ b/command/rakp34.cpp
@@ -10,11 +10,16 @@
 #include <cstring>
 #include <phosphor-logging/log.hpp>
 
+#include <nlohmann/json.hpp>
+
+
 using namespace phosphor::logging;
 
 namespace command
 {
 
+static int getKGKey(uint8_t channelNum, std::string& ks, std::string& kv);
+
 void applyIntegrityAlgo(const uint32_t bmcSessionID)
 {
     auto session =
@@ -218,7 +223,21 @@ std::vector<uint8_t> RAKP34(const std::vector<uint8_t>& inPayload,
     std::copy_n(session->userName.data(), userLength, iter);
 
     // Generate Session Integrity Key
-    auto sikOutput = authAlgo->generateHMAC(input);
+    // if enable the BMC Key of the channel
+    // key state is locked and kekey value is not 0
+    // generate the SIK with kgkey
+    std::string ks;
+    std::string kv;
+    std::vector<uint8_t> sikOutput;
+    auto rt = getKGKey(session->channelNum(), ks, kv);
+    if ( (rt == 0) &&(ks == "lock" || ks == "locked") && (kv.size() > 0))
+    {
+        std::copy_n(kv.c_str(), kv.size(), authAlgo->kgKey.data());
+        sikOutput = authAlgo->generateSIK(input);
+    }else{
+        // not enable the kgkey, using default way to generate SIK
+        sikOutput = authAlgo->generateHMAC(input);
+    }
 
     // Update the SIK in the Authentication Algo Interface
     authAlgo->sessionIntegrityKey.insert(authAlgo->sessionIntegrityKey.begin(),
@@ -276,4 +295,83 @@ std::vector<uint8_t> RAKP34(const std::vector<uint8_t>& inPayload,
     return outPayload;
 }
 
+static constexpr const char* kgkeyConfigDefaultFilename =
+    "/var/lib/ipmi/kgkey_config.json";
+static constexpr const char* bmcKeyString = "bmc_key";
+static constexpr const char* bmcKeyStateString = "keystate";
+static constexpr const char* bmcKeyValueString = "keyvalue";
+
+using Json = nlohmann::json;
+
+static Json _readJsonFile(const std::string& configFile)
+{
+    std::ifstream jsonFile(configFile);
+    if (!jsonFile.good())
+    {
+        log<level::INFO>("JSON file not found",
+                         entry("FILE_NAME=%s", configFile.c_str()));
+        return nullptr;
+    }
+
+    Json data = nullptr;
+    try
+    {
+        data = Json::parse(jsonFile, nullptr, false);
+    }
+    catch (Json::parse_error& e)
+    {
+        log<level::DEBUG>("Corrupted channel config.",
+                          entry("MSG=%s", e.what()));
+        throw std::runtime_error("Corrupted channel config file");
+    }
+
+    return data;
+}
+
+static int getKGKey(uint8_t channelNum, std::string& ks, std::string& kv)
+{
+    Json data = _readJsonFile(kgkeyConfigDefaultFilename);
+    if (data.empty())
+    {
+        ks = "";
+        kv = "";
+    }else{
+        try
+        {
+            std::string chKey = std::to_string(channelNum);
+            Json jsonChData = data[chKey].get<Json>();
+            if (jsonChData.is_null())
+            {
+                log<level::ERR>("Channel data is null");
+                return -EBADMSG;
+            }
+
+            Json jBMCKey = jsonChData[bmcKeyString].get<Json>();
+            if (jBMCKey.is_null())
+            {
+                ks = "";
+                kv = "";
+            }
+            else
+            {
+                ks = jBMCKey[bmcKeyStateString].get<std::string>();
+                kv = jBMCKey[bmcKeyValueString].get<std::string>();
+            }
+        }
+        catch (const Json::exception& e)
+        {
+            log<level::DEBUG>("Json Exception caught.",
+                              entry("MSG=%s", e.what()));
+            return -EBADMSG;
+        }
+        catch (const std::invalid_argument& e)
+        {
+            log<level::ERR>("Corrupted config.", entry("MSG=%s", e.what()));
+            return -EBADMSG;
+        }
+    }
+
+    return 0;
+}
+
 } // namespace command
