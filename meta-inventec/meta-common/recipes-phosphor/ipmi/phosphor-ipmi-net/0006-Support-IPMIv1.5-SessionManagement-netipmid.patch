From e8ec731fe1e690356479d281a2d7836602de7893 Mon Sep 17 00:00:00 2001
From: "sun.cwsun" <sun.cwsun@inventec.com>
Date: Sun, 26 Sep 2021 21:14:37 -0700
Subject: [PATCH] [Transformers][SW] Support IPMI v1.5 Session Management

    Symptom/Reason :
        - The OpenBMC does not support IPMI v1.5 RMCP type Session Management

    Root Cause:
        - The OpenBMC does not support IPMI v1.5 RMCP type Session Management

    Solution/Change:
        [phosphor-dbus-interfaces]
            - add rmcpType into SessionInfo.interface.yaml
              -- the rmcpType will indicate if the session is RMCP or RMCP+ type.

        [phosphor-ipmi-host]
            - support RMCP type session of "Get Session Info" command
              -- ipmiAppGetSessionInfo()
              -- getSessionDetails()
              -- remove garbage code

        [phosphor-ipmi-net]
            - When user assign into the system via netipmid and register a session.
              The registered session will be record its type of RMCP or RMCP+ and be kept
              in the dbus system.
	    - enable per-message authentication

    Entry Test:
        - Open RMCP(-Ilan) and RMCP+(-Ilanplus) sessions with IPMI shell
          -- ipmitool -I lan -H myqemu -U root -P 0penBmc -p 2623 shell
          -- ipmitool -I lanplus -H myqemu -U root -P 0penBmc -p 2623 -C17 shell
          -- ipmitool -I lanplus -H myqemu -U root -P 0penBmc -p 2623 -C17 shell
          -- ipmitool -I lan -H myqemu -U root -P 0penBmc -p 2623

        - then view the session info
          session info all
          >
            session handle                : 13
            slot count                    : 15
            active sessions               : 4
            user id                       : 2
            privilege level               : ADMINISTRATOR
            session type                  : IPMIv1.5
            channel number                : 0x01

            session handle                : 3
            slot count                    : 15
            active sessions               : 4
            user id                       : 2
            privilege level               : ADMINISTRATOR
            session type                  : IPMIv1.5
            channel number                : 0x01

            session handle                : 1
            slot count                    : 15
            active sessions               : 4
            user id                       : 2
            privilege level               : ADMINISTRATOR
            session type                  : IPMIv2/RMCP+
            channel number                : 0x01

            session handle                : 14
            slot count                    : 15
            active sessions               : 4
            user id                       : 2
            privilege level               : ADMINISTRATOR
            session type                  : IPMIv2/RMCP+
            channel number                : 0x01
---
 command/channel_auth.cpp | 2 +-
 message_parsers.cpp      | 9 ++++++++-
 sessions_manager.cpp     | 4 +++-
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/command/channel_auth.cpp b/command/channel_auth.cpp
index 451fb27..9a389e5 100644
--- a/command/channel_auth.cpp
+++ b/command/channel_auth.cpp
@@ -52,7 +52,7 @@ std::vector<uint8_t>
 
     response->reserved3 = 0;
     response->KGStatus = 0;       // KG is set to default
-    response->perMessageAuth = 1; // Per-message Authentication disabled
+    response->perMessageAuth = 0; // Per-message Authentication enable, bug492
     response->userAuth = 0;       // User Level Authentication is enabled
     uint8_t maxChUsers = 0;
     uint8_t enabledUsers = 0;
diff --git a/message_parsers.cpp b/message_parsers.cpp
index d02cee4..3b34a10 100644
--- a/message_parsers.cpp
+++ b/message_parsers.cpp
@@ -221,8 +221,15 @@ std::vector<uint8_t> flatten(std::shared_ptr<Message> outMessage,
         header->base.rmcp.classOfMsg = static_cast<uint8_t>(ClassOfMsg::IPMI);
         header->base.format.formatType =
             static_cast<uint8_t>(parser::SessionHeader::IPMI15);
-        header->sessSeqNum = 0;
         header->sessId = sessionid;
+	//fix bug557, outbound sequence number does not increase
+        if(sessionid == 0x00){
+            header->sessSeqNum = 0;
+        }else{
+            auto sequenceNum = session->sequenceNums.get(false);
+            header->sessSeqNum = endian::to_ipmi(sequenceNum);
+            session->sequenceNums.increment();
+        }
         header->payloadLength =
             static_cast<uint8_t>(outMessage->payload.size());
     }else
diff --git a/sessions_manager.cpp b/sessions_manager.cpp
index e1611b3..88579dd 100644
--- a/sessions_manager.cpp
+++ b/sessions_manager.cpp
@@ -150,6 +150,7 @@ std::shared_ptr<Session>
         session->sessionHandle(sessionHandle);
         session->channelNum(getInterfaceIndex());
         session->userID(ipmi::ipmiUserGetUserId(userName));
+        session->rmcpType(0);
         return session;
     }
 
@@ -245,7 +246,8 @@ std::shared_ptr<Session>
 
         sessionsMap.emplace(bmcSessionID, session);
         session->sessionHandle(sessionHandle);
-        
+        session->rmcpType(1);
+
         return session;
     }
 
