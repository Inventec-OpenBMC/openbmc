From 5cd16c4b65101929fc5b5f9e072bab9799a4d004 Mon Sep 17 00:00:00 2001
From: cynthia <wu.cynthia@inventec.com>
Date: Thu, 25 Mar 2021 19:35:55 +0800
Subject: [PATCH] Fix Can't "Set FRU data" by raw command, but successful by
 ipmitool command line.

	Sympthon/Reason:
		The output of fru read command doesn't reflects the changes by fru write command

	Root Cause:
		The fru data parsed by fru read mismatch with eeprom file we modify with fru write

	Solution/Changes:
		1.Modify ipmiStorageReadFruData function, get fru raw data by reading eeprom file
		directly
		2.Modify ipmiStorageGetFruInvAreaInfo function to get correct fru size based on fru
		read changes

	Entry test:
		[fru print]
		sysadmin@goldentalon:~# ipmitool fru print 0
		 Chassis Type          : Rack Mount Chassis
		 Chassis Part Number   :
		 Chassis Serial        :
		 Board Mfg Date        : Thu Jan 14 09:51:00 2021 UTC
		 Board Mfg             : Inventec
		 Board Product         : TRANSFORMERS
		 Board Serial          :
		 Board Part Number     : 1395A3194504
		 Board Extra           :  X02
		 Product Manufacturer  : Inventec
		 Product Name          : TRANSFORMERS
		 Product Part Number   :
		 Product Version       :
		 Product Serial        :
		 Product Asset Tag     :
		 Product Extra         :

		[fru raw command (read 0x11/write 0x12)]
		sysadmin@goldentalon:~# ipmitool raw 0xa 0x11 0x0 0x0 0x0 0xff
		 ff 01 00 01 0e 1e 00 00 d2 01 0d 17 d8 20 20 20
		 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
		 20 20 20 20 20 e0 20 20 20 20 20 20 20 20 20 20
		(skip)
		 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
		 ed 01 22 00 d0 49 6e 76 65 6e 74 65 63 20 20 20

		sysadmin@goldentalon:~# ipmitool raw 0xa 0x11 0x0 0x0 0x0 0xff
		 ff ff 00 01 0e 1e 00 00 d2 01 0d 17 d8 20 20 20
		 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
		 20 20 20 20 20 e0 20 20 20 20 20 20 20 20 20 20
		(skip)
		 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
		 ed 01 22 00 d0 49 6e 76 65 6e 74 65 63 20 20 20

		[fru inv area info (0x10)]
		sysadmin@goldentalon:~# ipmitool raw 0xa 0x10 0
		 00 04 00

		[fru read]
		sysadmin@goldentalon:~# ipmitool fru read 0 test.bin
		Fru Size         : 1024 bytes
		Done
		sysadmin@goldentalon:~# hexdump -C test.bin
		00000000  01 00 00 01 00 00 00 fe  01 09 19 49 bd c2 ca 49  |...........I...I|
		00000010  6e 76 65 6e 74 65 63 20  20 c8 53 43 4d 20 20 20  |nventec  .SCM   |
		00000020  20 20 ca 20 20 20 20 20  20 20 20 20 20 cc 31 33  |  .          .13|
		00000030  39 35 41 33 32 30 39 34  30 31 c9 46 52 55 20 76  |95A3209401.FRU v|
		00000040  30 2e 30 39 c4 41 20 20  20 c1 00 00 00 00 00 00  |0.09.A   .......|
		00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
		*
		00000400
---
 storagehandler.cpp | 313 ++++++++++++++++++++++++++++++++++-----------
 1 file changed, 240 insertions(+), 73 deletions(-)

diff --git a/storagehandler.cpp b/storagehandler.cpp
index f03eae3..d60f4ac 100644
--- a/storagehandler.cpp
+++ b/storagehandler.cpp
@@ -28,6 +28,15 @@
 #include <variant>
 #include <xyz/openbmc_project/Common/error.hpp>
 
+static std::vector<uint8_t> fruCache;
+static uint8_t lastDevId = 0xFF;
+static uint8_t cacheBus = 0xFF;
+static uint8_t cacheAddr = 0XFF;
+static uint8_t writeBus = 0xFF;
+static uint8_t writeAddr = 0XFF;
+
+constexpr static const char* fruDeviceServiceName = "xyz.openbmc_project.FruDevice";
+
 void register_netfn_storage_functions() __attribute__((constructor));
 
 unsigned int g_sel_time = 0xFFFFFFFF;
@@ -47,7 +56,6 @@ constexpr auto TIME_INTERFACE = "xyz.openbmc_project.Time.EpochTime";
 constexpr auto BMC_TIME_PATH = "/xyz/openbmc_project/time/bmc";
 constexpr auto DBUS_PROPERTIES = "org.freedesktop.DBus.Properties";
 constexpr auto PROPERTY_ELAPSED = "Elapsed";
-
 } // namespace
 
 namespace cache
@@ -638,6 +646,81 @@ bool isFruPresent(const std::string& fruPath)
     return std::get<bool>(propValue);
 }
 
+
+ipmi::Cc getFru(uint8_t fruID)
+{
+    std::string eeprom_path="";
+    sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
+    
+    if (lastDevId == fruID && fruID != 0xFF)
+    {
+        return ipmi::ccSuccess;
+    }
+    auto iter = frus.find(fruID);
+
+    if (iter == frus.end())
+    {
+        fprintf(stderr,"Unsupported fru id %x\n", fruID);
+        return ipmi::ccInvalidFieldRequest;
+    }
+
+    /*Get eeprom path with dbus interface*/
+    auto& instanceList = iter->second;
+    for (auto& instance : instanceList){
+        std::string objPath = invObjPath+instance.path;
+        auto service = ipmi::getService(bus, invItemInterface,objPath.c_str() );
+                
+        try{
+            auto temp = ipmi::getDbusProperty(
+                bus, service, objPath, invItemInterface, "EepromPath");
+            eeprom_path =  std::get<std::string>(temp);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+                fprintf(stderr,"Error in reading property values");
+        }    
+    }
+    if(eeprom_path==""){
+        std::fprintf(stderr, "Failed to get the path for eeprom file for fru %x\n", fruID);
+        return ipmi::ccUnspecifiedError;    
+    }
+
+    fruCache.clear();
+
+    std::string I2CSysPath = "/sys/bus/i2c/devices/";
+    auto StartPos = eeprom_path.find(I2CSysPath);
+
+    std::string Bus_AddrStr = eeprom_path.substr(StartPos + I2CSysPath.size());
+    auto BusEndPos = Bus_AddrStr.find('-');
+    cacheBus  = std::stoi(Bus_AddrStr.substr(0,BusEndPos));
+    cacheAddr = std::stoi(Bus_AddrStr.substr(BusEndPos+1),nullptr,16);
+
+    // Get Fru Data
+    auto method = bus.new_method_call(fruDeviceServiceName,"/xyz/openbmc_project/FruDevice", 
+       "xyz.openbmc_project.FruDeviceManager", "GetRawFru");
+    method.append(cacheBus,cacheAddr);
+    auto reply  = bus.call(method);
+
+
+    if (reply.is_method_error())
+    {
+        phosphor::logging::log<phosphor::logging::level::ERR>(
+            "Couldn't get raw fru",
+            phosphor::logging::entry("ERROR"));
+
+        cacheBus = 0xFF;
+        cacheAddr = 0xFF;
+        return ipmi::ccResponseError;
+    }
+
+    reply.read(fruCache);
+    lastDevId = fruID;
+
+    return ipmi::ccSuccess;
+}
+
+
+
 /** @brief implements the get FRU Inventory Area Info command
  *
  *  @returns IPMI completion code plus response data
@@ -649,29 +732,82 @@ ipmi::RspType<uint16_t, // FRU Inventory area size in bytes,
               >
     ipmiStorageGetFruInvAreaInfo(uint8_t fruID)
 {
-
-    auto iter = frus.find(fruID);
-    if (iter == frus.end())
+#if 1
+    if (fruID == 0xFF)
     {
-        return ipmi::responseSensorInvalid();
+        return ipmi::responseInvalidFieldRequest();
     }
 
-    auto path = iter->second[0].path;
-    if (!isFruPresent(path))
-    {
-        return ipmi::responseSensorInvalid();
-    }
-    try
+    ipmi::Cc ret = getFru(fruID);
+    if (ret != ipmi::ccSuccess)
     {
-        return ipmi::responseSuccess(
-            static_cast<uint16_t>(getFruAreaData(fruID).size()),
-            static_cast<uint8_t>(AccessMode::bytes));
+        return ipmi::response(ret);
     }
-    catch (const InternalFailure& e)
+
+    return ipmi::responseSuccess(
+            static_cast<uint16_t>(fruCache.size()),
+            static_cast<uint8_t>(AccessMode::bytes)
+        );
+
+#else
+    sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
+    std::string eeprom_path="";
+    std::string service=""; 
+    std::vector<uint8_t> file_data;
+    auto iter = frus.find(fruID);
+
+    if (iter == frus.end())
     {
-        log<level::ERR>(e.what());
+        fprintf(stderr,"Unsupported fru id %x\n", fruID);
         return ipmi::responseUnspecifiedError();
     }
+
+    if(lastDevId!=fruID ){
+        /*Get eeprom path with dbus interface*/
+        auto& instanceList = iter->second;
+        for (auto& instance : instanceList)
+        {
+            std::string objPath = invObjPath+instance.path;
+            service = ipmi::getService(bus, invItemInterface,objPath.c_str() );
+                
+            try
+            {
+                auto temp = ipmi::getDbusProperty(
+                    bus, service, objPath, invItemInterface, "EepromPath");
+                eeprom_path =  std::get<std::string>(temp);
+            }
+            catch (const sdbusplus::exception::SdBusError& e)
+            {
+                fprintf(stderr,"Error in reading property values");
+            }    
+        }
+        if(eeprom_path==""){
+            std::fprintf(stderr, "Failed to get the path for eeprom file for fru %x\n", fruID);
+            return ipmi::responseUnspecifiedError();    
+        }
+
+        try{
+            std::ifstream eeprom_file(eeprom_path, std::ios::binary| std::ios::ate);
+            const unsigned int file_length = eeprom_file.tellg();
+            fruCache.clear();
+            fruCache.resize(file_length);
+            eeprom_file.seekg(0);
+            if(!eeprom_file.read((char*)fruCache.data(), file_length) ){
+                fprintf(stderr, "Read fru header from file %s failed\n", eeprom_path.c_str());
+                return ipmi::responseUnspecifiedError();
+            }
+        }catch (std::ios_base::failure& e) {
+            fprintf(stderr,"Failed to read eeprom file %s\n", eeprom_path.c_str());
+            return ipmi::responseUnspecifiedError();    
+        }        
+        lastDevId = fruID;
+    }
+
+    return ipmi::responseSuccess(
+            static_cast<uint16_t>(fruCache.size()),
+            static_cast<uint8_t>(AccessMode::bytes)
+        );
+#endif
 }
 
 /**@brief implements the Read FRU Data command
@@ -688,50 +824,38 @@ ipmi::RspType<uint8_t,              // count returned
     ipmiStorageReadFruData(uint8_t fruDeviceId, uint16_t offset,
                            uint8_t readCount)
 {
+   
+    int readsize;    
+
     if (fruDeviceId == 0xFF)
     {
         return ipmi::responseInvalidFieldRequest();
     }
 
-    auto iter = frus.find(fruDeviceId);
-    if (iter == frus.end())
-    {
-        return ipmi::responseSensorInvalid();
-    }
+    ipmi::Cc status = getFru(fruDeviceId);
 
-    try
+    if (status != ipmi::ccSuccess)
     {
-        const auto& fruArea = getFruAreaData(fruDeviceId);
-        auto size = fruArea.size();
-
-        if (offset >= size)
-        {
-            return ipmi::responseParmOutOfRange();
-        }
-
-        // Write the count of response data.
-        uint8_t returnCount;
-        if ((offset + readCount) <= size)
-        {
-            returnCount = readCount;
-        }
-        else
-        {
-            returnCount = size - offset;
-        }
-
-        std::vector<uint8_t> fruData((fruArea.begin() + offset),
-                                     (fruArea.begin() + offset + returnCount));
-
-        return ipmi::responseSuccess(returnCount, fruData);
+        return ipmi::response(status);
     }
-    catch (const InternalFailure& e)
+
+    int size=fruCache.size();
+    if (offset > size)
     {
-        log<level::ERR>(e.what());
-        return ipmi::responseUnspecifiedError();
+        return ipmi::responseParmOutOfRange();
+    }   
+ 
+    if(offset+readCount<=fruCache.size()){
+        readsize=readCount;
+    }else{
+        readsize=size-offset;
     }
+        
+    std::vector<uint8_t> frudata ( (fruCache.begin()+offset), (fruCache.begin()+offset+readsize) );
+    return ipmi::responseSuccess(readsize, frudata);
 }
 
+
 ipmi::RspType<uint8_t,  // SDR version
               uint16_t, // record count LS first
               uint16_t, // free space in bytes, LS first
@@ -754,10 +878,39 @@ ipmi::RspType<uint8_t,  // SDR version
                                  operationSupport);
 }
 
+bool writeFru()
+{
+    if (writeBus == 0xFF && writeAddr == 0xFF)
+    {
+        return true;
+    }
+    std::shared_ptr<sdbusplus::asio::connection> dbus = getSdBus();
+    sdbusplus::message::message writeFru = dbus->new_method_call(
+        fruDeviceServiceName, "/xyz/openbmc_project/FruDevice",
+        "xyz.openbmc_project.FruDeviceManager", "WriteFru");
+    writeFru.append(writeBus, writeAddr, fruCache);
+    try
+    {
+        sdbusplus::message::message writeFruResp = dbus->call(writeFru);
+    }
+    catch (sdbusplus::exception_t&)
+    {
+        // todo: log sel?
+        phosphor::logging::log<phosphor::logging::level::ERR>(
+            "error writing fru");
+        return false;
+    }
+    writeBus = 0xFF;
+    writeAddr = 0xFF;
+    return true;
+}
+
+
 ipmi::RspType<uint8_t>
     ipmiStorageWriteFruData(uint8_t fruDeviceId, uint16_t fruInventoryOffset,
                             std::vector<uint8_t>& dataToWrite)
 {
+    fprintf(stderr,"fru write\n");
     sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
     std::vector<char> file_data;
     std::string result;
@@ -779,7 +932,7 @@ ipmi::RspType<uint8_t>
     {
         std::string objPath = invObjPath+instance.path;
         service = ipmi::getService(bus, invItemInterface,objPath.c_str() );
-        
+            
         try
         {
             auto temp = ipmi::getDbusProperty(
@@ -800,35 +953,49 @@ ipmi::RspType<uint8_t>
     }else if(eeprom_service==""){
         std::fprintf(stderr, "Failed to get the service name for fru %x\n", fruDeviceId);
         return ipmi::responseUnspecifiedError();     
+    }    
+#if 0
+    if(lastDevId!=fruDeviceId){
+        try{
+            std::ifstream eeprom_file(eeprom_path, std::ios::binary | std::ios::ate);
+            const unsigned int file_length = eeprom_file.tellg();
+            fruCache.clear();
+            fruCache.resize(file_length);
+            eeprom_file.seekg(0);
+            if(!eeprom_file.read((char*)fruCache.data(), file_length)){
+                fprintf(stderr, "Read file %s failed\n", eeprom_path.c_str());
+                return ipmi::responseUnspecifiedError();
+            }     
+        }
+        catch (std::ios_base::failure& e) {
+            fprintf(stderr,"Failed to read eeprom file %s\n", eeprom_path.c_str());
+            return ipmi::responseUnspecifiedError();    
+        }
+        lastDevId = fruDeviceId;
     }
-
-    try{
-        std::ifstream eeprom_file(eeprom_path, std::ios::binary | std::ios::ate);
-        const unsigned int file_length = eeprom_file.tellg();
-        file_data.resize(file_length);
-        eeprom_file.seekg(0);
-        if(!eeprom_file.read(&file_data[0], file_length)){
-            fprintf(stderr, "Read file %s failed\n", eeprom_path.c_str());
-            return ipmi::responseUnspecifiedError();
-        }     
-    }
-    catch (std::ios_base::failure& e) {
-        fprintf(stderr,"Failed to read eeprom file %s\n", eeprom_path.c_str());
-        return ipmi::responseUnspecifiedError();    
+#else
+    
+    ipmi::Cc status = getFru(fruDeviceId);
+    if (status != ipmi::ccSuccess)
+    {
+        return ipmi::response(status);
     }
+    
+#endif
+    writeBus = cacheBus;
+    writeAddr = cacheAddr;
 
-
-    if ((int)(file_data.size()) < lastWriteAddr)
+    if ((int)(fruCache.size()) < lastWriteAddr)
     {
-        file_data.resize(fruInventoryOffset + writeLen);
+        fruCache.resize(fruInventoryOffset + writeLen);
     }
 
-    std::copy(dataToWrite.begin(), dataToWrite.begin() + writeLen, file_data.begin() + fruInventoryOffset);
+    std::copy(dataToWrite.begin(), dataToWrite.begin() + writeLen, fruCache.begin() + fruInventoryOffset);
+    for(unsigned int i=0;i<writeLen;i++){
+        fprintf(stderr, "%d %x %d %x\n", i,dataToWrite[i],i+fruInventoryOffset,fruCache[i+fruInventoryOffset]);
+    }
 
-    /* write all data to eeprom file*/
-    int eeprom = open(eeprom_path.c_str(), O_RDWR | O_CLOEXEC);
-    write(eeprom, file_data.data(), file_data.size());
-    close(eeprom);
+    writeFru();
 
     /* run service to parse and update new fru info*/
     try{
@@ -840,9 +1007,9 @@ ipmi::RspType<uint8_t>
     {
         fprintf(stderr,"Error in starting service %s\n", eeprom_service.c_str());
         return ipmi::responseUnspecifiedError();
-    }  
+    }
 
-    return ipmi::responseSuccess();
+    return ipmi::responseSuccess(writeLen);
 }
 
 void register_netfn_storage_functions()
-- 
2.17.1

