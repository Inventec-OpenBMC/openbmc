From 7a347ac41fe8b43c23be89ced1ee0b6d0f5598f6 Mon Sep 17 00:00:00 2001
From: "Lin.TommySC" <lin.tommysc@inventec.com>
Date: Wed, 28 Apr 2021 08:06:17 +0000
Subject: [PATCH] Implement LAN Config Community String

Symptom/Reason :
    - Implement LAN Config Community String

Root Cause:
    - N/A

Solution/Change:
    [phospher-ipmi-config]
        - Create lan_config.json to store lan config parameters
        - Add community_str config name with default value "public"
    [phospher-ipmi-host]
        - Add entry for command handler and read/write fonfig value from/to lan_config.json
    [phospher-snmp]
        - Reads community_str value from lan_config.json before sending trap

Entry Test:
    - Get Community String
        ipmitool raw 0x0c 0x02 0x01 0x10 0x00 0x00
    - Set Community String
        ipmitool raw 0x0c 0x01 0x01 0x10 0x50 0x74 0x74 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
---
 transporthandler.cpp | 25 ++++++++++++++++++++
 transporthandler.hpp | 64 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 89 insertions(+)

diff --git a/transporthandler.cpp b/transporthandler.cpp
index 3d6d8f2..ce0a65e 100644
--- a/transporthandler.cpp
+++ b/transporthandler.cpp
@@ -1557,6 +1557,22 @@ RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
             channelCall<reconfigureGatewayMAC<AF_INET>>(channel, gatewayMAC);
             return responseSuccess();
         }
+        case LanParam::CommunityStr:
+        {
+            std::array<uint8_t, 18> bytes;
+            std::array<uint8_t, 19> raw_str = {0};
+            if (req.unpack(bytes) != 0 || !req.fullyUnpacked())
+            {
+                return responseReqDataLenInvalid();
+            }
+            std::copy(bytes.begin(), bytes.end(), raw_str.begin());
+            std::string comm_str((char*)raw_str.data());
+            if (updateConfigValue<std::string>(LAN_CONFIG_COMM_STR, comm_str))
+            {
+                return responseResponseError();
+            }
+            return responseSuccess();
+        }
         case LanParam::VLANId:
         {
             uint12_t vlanData = 0;
@@ -1905,6 +1921,15 @@ RspType<message::Payload> getLan(Context::ptr ctx, uint4_t channelBits,
             ret.pack(dataRef(mac));
             return responseSuccess(std::move(ret));
         }
+        case LanParam::CommunityStr:
+        {
+            std::string comm_str("public");
+            std::array<uint8_t, 18> resp = {0};
+            loadConfigValue<std::string>(LAN_CONFIG_COMM_STR, comm_str);
+            std::copy(comm_str.begin(), comm_str.end(), resp.begin());
+            ret.pack(dataRef(resp));
+            return responseSuccess(std::move(ret));
+        }
         case LanParam::VLANId:
         {
             uint16_t vlan = channelCall<getVLANProperty>(channel);
diff --git a/transporthandler.hpp b/transporthandler.hpp
index f5b9eb9..0117eba 100644
--- a/transporthandler.hpp
+++ b/transporthandler.hpp
@@ -2,12 +2,18 @@
 
 #include <cstdint>
 #include <ipmid/api-types.hpp>
+#include <iomanip>
+#include <fstream>
+#include <nlohmann/json.hpp>
+#include <phosphor-logging/log.hpp>
 
 namespace ipmi
 {
 namespace transport
 {
 
+using namespace phosphor::logging;
+
 /** @brief IPMI LAN Parameters */
 enum class LanParam : uint8_t
 {
@@ -20,6 +26,7 @@ enum class LanParam : uint8_t
     SubnetMask = 6,
     Gateway1 = 12,
     Gateway1MAC = 13,
+    CommunityStr = 16,
     VLANId = 20,
     CiphersuiteSupport = 22,
     CiphersuiteEntries = 23,
@@ -112,5 +119,62 @@ constexpr uint16_t VLAN_ENABLE_FLAG = 0x8000;
 constexpr uint8_t MAX_IPV6_STATIC_ADDRESSES = 15;
 constexpr uint8_t MAX_IPV6_DYNAMIC_ADDRESSES = 15;
 
+// Config file for LAN Config Parameters
+constexpr auto LAN_CFG_FILE = "/usr/share/ipmi-providers/lan_config.json";
+// Config name for LAN Config Parameters
+constexpr auto LAN_CONFIG_COMM_STR = "community_str";
+
+/** @brief get config value from LAN configuration file.
+ *  @param[in] name - config name.
+ *  @param[in] val - value of the given config name.
+ */
+template <typename T> int loadConfigValue(const std::string& name, T& val)
+{
+    std::ifstream configFile(LAN_CFG_FILE);
+    if (!configFile.is_open())
+    {
+        log<level::ERR>("loadConfigValue : Cannot open config path");
+        return -1;
+    }
+
+    auto data = nlohmann::json::parse(configFile, nullptr);
+
+    if (data.is_discarded())
+    {
+        log<level::ERR>("loadConfigValue JSON parser failure");
+        return -2;
+    }
+
+    if (data.contains(name))
+    {
+        val = data[name];
+        return 0;
+    }
+
+    return -3;
+}
+
+template <typename T> int updateConfigValue(const std::string& name, T val)
+{
+    std::ifstream configFile(LAN_CFG_FILE);
+    if (!configFile.is_open())
+    {
+        log<level::ERR>("loadConfigValue : Cannot open config path");
+        return -1;
+    }
+    auto data = nlohmann::json::parse(configFile, nullptr);
+
+    if (data.is_discarded())
+    {
+        log<level::ERR>("loadConfigValue JSON parser failure");
+        return -2;
+    }
+
+    data[name] = val;
+    std::ofstream configStream(LAN_CFG_FILE);
+    configStream << std::setw(4) << data << std::endl;
+    return 0;
+}
+
 } // namespace transport
 } // namespace ipmi
-- 
2.7.4

