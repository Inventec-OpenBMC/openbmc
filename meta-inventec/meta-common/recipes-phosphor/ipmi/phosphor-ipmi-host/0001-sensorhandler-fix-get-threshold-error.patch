From 4ef93b45c5c1be9dac09350a6d30da35dceb95ca Mon Sep 17 00:00:00 2001
From: "pj.chen" <chen.pj@inventec.com>
Date: Mon, 8 Feb 2021 03:21:08 +0000
Subject: [PATCH 2/3] - fix get threshold error

If there's no threshold config in dbus, just ignore it.
We should use "try" to catch the error to prevent abnormal exit.

And also the resp should be init first.
---
 sensorhandler.cpp | 100 +++++++++++++++++++++++++++++++++---------------------
 1 file changed, 62 insertions(+), 38 deletions(-)

diff --git a/sensorhandler.cpp b/sensorhandler.cpp
index 775f651..cafe2ea 100644
--- a/sensorhandler.cpp
+++ b/sensorhandler.cpp
@@ -487,55 +487,79 @@ get_sdr::GetSensorThresholdsResponse getSensorThresholds(uint8_t sensorNum)
 
     auto service = ipmi::getService(bus, info.sensorInterface, info.sensorPath);
 
-    auto warnThresholds = ipmi::getAllDbusProperties(
-        bus, service, info.sensorPath, warningThreshIntf);
+    /*
+    Inventec patch: [sensorhandler] - fix get threshold error
 
-    double warnLow = std::visit(ipmi::VariantToDoubleVisitor(),
-                                warnThresholds["WarningLow"]);
-    double warnHigh = std::visit(ipmi::VariantToDoubleVisitor(),
-                                 warnThresholds["WarningHigh"]);
+    If there's no threshold config in dbus, just ignore it.
+    We should use "try" to catch the error to prevent abnormal exit.
 
-    if (warnLow != 0)
+    And also the resp should be init first.
+    */
+    memset(&resp, 0, sizeof(get_sdr::GetSensorThresholdsResponse));
+    try
     {
-        warnLow *= std::pow(10, info.scale - info.exponentR);
-        resp.lowerNonCritical = static_cast<uint8_t>(
-            (warnLow - info.scaledOffset) / info.coefficientM);
-        resp.validMask |= static_cast<uint8_t>(
-            ipmi::sensor::ThresholdMask::NON_CRITICAL_LOW_MASK);
-    }
+        auto warnThresholds = ipmi::getAllDbusProperties(
+            bus, service, info.sensorPath, warningThreshIntf);
+
+        double warnLow = std::visit(ipmi::VariantToDoubleVisitor(),
+                                    warnThresholds["WarningLow"]);
+        double warnHigh = std::visit(ipmi::VariantToDoubleVisitor(),
+                                     warnThresholds["WarningHigh"]);
 
-    if (warnHigh != 0)
+        if (warnLow != 0)
+        {
+            warnLow *= std::pow(10, info.scale - info.exponentR);
+            resp.lowerNonCritical = static_cast<uint8_t>(
+                (warnLow - info.scaledOffset) / info.coefficientM);
+            resp.validMask |= static_cast<uint8_t>(
+                ipmi::sensor::ThresholdMask::NON_CRITICAL_LOW_MASK);
+        }
+
+        if (warnHigh != 0)
+        {
+            warnHigh *= std::pow(10, info.scale - info.exponentR);
+            resp.upperNonCritical = static_cast<uint8_t>(
+                (warnHigh - info.scaledOffset) / info.coefficientM);
+            resp.validMask |= static_cast<uint8_t>(
+                ipmi::sensor::ThresholdMask::NON_CRITICAL_HIGH_MASK);
+        }
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
     {
-        warnHigh *= std::pow(10, info.scale - info.exponentR);
-        resp.upperNonCritical = static_cast<uint8_t>(
-            (warnHigh - info.scaledOffset) / info.coefficientM);
-        resp.validMask |= static_cast<uint8_t>(
-            ipmi::sensor::ThresholdMask::NON_CRITICAL_HIGH_MASK);
+        /* If there's not warning interface in dbus, skip the warning part */
     }
 
-    auto critThresholds = ipmi::getAllDbusProperties(
-        bus, service, info.sensorPath, criticalThreshIntf);
-    double critLow = std::visit(ipmi::VariantToDoubleVisitor(),
-                                critThresholds["CriticalLow"]);
-    double critHigh = std::visit(ipmi::VariantToDoubleVisitor(),
-                                 critThresholds["CriticalHigh"]);
 
-    if (critLow != 0)
+    try
     {
-        critLow *= std::pow(10, info.scale - info.exponentR);
-        resp.lowerCritical = static_cast<uint8_t>(
-            (critLow - info.scaledOffset) / info.coefficientM);
-        resp.validMask |= static_cast<uint8_t>(
-            ipmi::sensor::ThresholdMask::CRITICAL_LOW_MASK);
-    }
+        auto critThresholds = ipmi::getAllDbusProperties(
+            bus, service, info.sensorPath, criticalThreshIntf);
+        double critLow = std::visit(ipmi::VariantToDoubleVisitor(),
+                                    critThresholds["CriticalLow"]);
+        double critHigh = std::visit(ipmi::VariantToDoubleVisitor(),
+                                     critThresholds["CriticalHigh"]);
+
+        if (critLow != 0)
+        {
+            critLow *= std::pow(10, info.scale - info.exponentR);
+            resp.lowerCritical = static_cast<uint8_t>(
+                (critLow - info.scaledOffset) / info.coefficientM);
+            resp.validMask |= static_cast<uint8_t>(
+                ipmi::sensor::ThresholdMask::CRITICAL_LOW_MASK);
+        }
 
-    if (critHigh != 0)
+        if (critHigh != 0)
+        {
+            critHigh *= std::pow(10, info.scale - info.exponentR);
+            resp.upperCritical = static_cast<uint8_t>(
+                (critHigh - info.scaledOffset) / info.coefficientM);
+            resp.validMask |= static_cast<uint8_t>(
+                ipmi::sensor::ThresholdMask::CRITICAL_HIGH_MASK);
+        }
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
     {
-        critHigh *= std::pow(10, info.scale - info.exponentR);
-        resp.upperCritical = static_cast<uint8_t>(
-            (critHigh - info.scaledOffset) / info.coefficientM);
-        resp.validMask |= static_cast<uint8_t>(
-            ipmi::sensor::ThresholdMask::CRITICAL_HIGH_MASK);
+        /* If there's not critical interface in dbus, skip the critical part */
     }
 
     return resp;
-- 
2.7.4

