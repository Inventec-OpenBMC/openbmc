From ba6b3343ec30dc8982e1a26bcca5547df42acf4d Mon Sep 17 00:00:00 2001
From: anonymous <anonymous@inventec.com>
Date: Wed, 9 Sep 2020 15:43:14 -0400
Subject: [PATCH 09/11] Subject: [Patch][intel-ipmi-oem] Fix ipmi sdr list gets
 wrong data and enhance the performance

- Fix ipmi sdr list gets wrong data, if there is a dbus-sensor which doesn't have xyz.openbmc_project.Sensor.IpmiSensor interface.
- Enhance the performance of getting sensor number and obj path.

%% original patch: 0010-Fix-Get-Wrong-ObjPath-and-Enhance-the-performance.patch
---
 include/sdrutils.hpp | 302 ++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 253 insertions(+), 49 deletions(-)

diff --git a/include/sdrutils.hpp b/include/sdrutils.hpp
index 703ee2b..6f48402 100644
--- a/include/sdrutils.hpp
+++ b/include/sdrutils.hpp
@@ -54,6 +54,10 @@ static constexpr uint16_t lun1Sensor0 = 0x100;
 static constexpr uint16_t lun3Sensor0 = 0x300;
 static constexpr uint16_t invalidSensorNumber = 0xFFFF;
 static constexpr uint8_t reservedSensorNumber = 0xFF;
+static constexpr auto ipmiInterface = "xyz.openbmc_project.Sensor.IpmiSensor";
+static constexpr auto sensorNumProp = "sensorNumber";
+static constexpr auto propIntf = "org.freedesktop.DBus.Properties";
+static bool is_SensorNumMapReset = true;
 
 namespace details
 {
@@ -75,13 +79,19 @@ inline static bool getSensorSubtree(std::shared_ptr<SensorSubTree>& subtree)
         dbus,
         "type='signal',member='InterfacesAdded',arg0path='/xyz/openbmc_project/"
         "sensors/'",
-        [](sdbusplus::message::message& m) { sensorTreePtr.reset(); });
+        [](sdbusplus::message::message& m) {
+            sensorTreePtr.reset();
+            is_SensorNumMapReset = true;
+        });
 
     static sdbusplus::bus::match::match sensorRemoved(
         dbus,
         "type='signal',member='InterfacesRemoved',arg0path='/xyz/"
         "openbmc_project/sensors/'",
-        [](sdbusplus::message::message& m) { sensorTreePtr.reset(); });
+        [](sdbusplus::message::message& m) {
+            sensorTreePtr.reset();
+            is_SensorNumMapReset = true;
+        });
 
     bool sensorTreeUpdated = false;
     if (sensorTreePtr)
@@ -119,75 +129,255 @@ inline static bool getSensorSubtree(std::shared_ptr<SensorSubTree>& subtree)
     return sensorTreeUpdated;
 }
 
-inline static bool getSensorNumMap(std::shared_ptr<SensorNumMap>& sensorNumMap)
+using  SensorSubTreeItem = std::pair< std::string,
+                                boost::container::flat_map<std::string, std::vector<std::string>> >;
+enum sensorNumMapOption
 {
-    constexpr auto ipmiInterface = "xyz.openbmc_project.Sensor.IpmiSensor";
-    constexpr auto sensorNumProp = "sensorNumber";
-    constexpr auto propIntf = "org.freedesktop.DBus.Properties";
-    std::string connection;
-    std::string path;
-    std::variant<uint64_t> sn;
-    uint8_t sensorNumber;
-    bool sensorNumMapUpated = false;
+    getSensorNumMapPtr = 0,
+    update_full,
+    update_ByNum,
+    update_ByPath
+};
 
-    static std::shared_ptr<SensorNumMap> sensorNumMapPtr = std::make_shared<SensorNumMap>();
+inline static bool _updateSensorNumMap(SensorSubTreeItem& sensor, sdbusplus::bus::bus& dbus,
+                                        uint8_t& sensorNumber, std::string& path,
+                                        std::shared_ptr<SensorNumMap>& sensorNumMap)
+{
+    /*
+    * We use the subvector of the sensorTree container to store sensor number as a chache.
+    * That can save the time for calling dbus to sensor number.
+    */
+    auto& subVect = sensor.second.begin()->second;
+    auto sensorNum_itr = subVect.rbegin();
+    bool ret = false;
+    std::string connection = sensor.second.begin()->first;
+    path = sensor.first;
 
+    if constexpr (debug)
+    {
+        std::fprintf(stderr, "[%s] OBJ_PATH: %s, SERVICE: %s\n",
+                    __func__, path.c_str(), connection.c_str());
+    }
+
+    if (boost::ends_with(*sensorNum_itr, ":SensorNum"))
+    {
+        sensorNumber = std::stoi(*sensorNum_itr);
+        int findNum = sensorNumber;
+        /*
+        * Note:
+        * Currently we don't consider LUN and because we use bimap container which cannot allow duplicated member
+        * that means we cannot have the same sensor number but the different path, vice versa.
+        */
+        if (sensorNumMap->left.find(findNum) == sensorNumMap->left.end())
+        {
+            sensorNumMap->insert(
+                SensorNumMap::value_type(sensorNumber, path));
+        }
+        ret = true;
+    }
+    else
+    {
+        // check it has the dbus interface "ipmiInterface"
+        if (std::find(sensorNum_itr, subVect.rend(), ipmiInterface) != subVect.rend())
+        {
+            try
+            {
+                auto methodCall = dbus.new_method_call(connection.c_str(), path.c_str(), propIntf, "Get");
+                methodCall.append(ipmiInterface, sensorNumProp);
+
+                auto reply = dbus.call(methodCall);
+                if (reply.is_method_error())
+                {
+                    if constexpr (debug)
+                    {
+                        std::fprintf(stderr, "[%s] Method call reply fail\n", __func__);
+                    }
+                    return ret;
+                }
+
+                std::variant<uint64_t> sn;
+                reply.read(sn);
+                sensorNumber = static_cast<uint8_t>(std::get<uint64_t>(sn));
+                sensorNumMap->insert(
+                    SensorNumMap::value_type(sensorNumber, path));
+
+                // put the sensor number to the subvector as a cache
+                subVect.emplace_back(std::to_string(sensorNumber)+":SensorNum");
+                ret = true;
+
+                if constexpr (debug)
+                {
+                    std::fprintf(stderr, "[%s] Insert Sensor(#0x%x), path:%s\n",
+                        __func__, sensorNumber, path.c_str());
+                }
+            }
+            catch (std::exception &)
+            {
+                if constexpr (debug)
+                {
+                    std::fprintf(stderr, "[%s] Get Sensor(#0x%x) Connection Fail\nPath:%s\n",
+                        __func__, sensorNumber, path.c_str());
+                }
+            }
+        }
+    }
+    return ret;
+}
+inline static bool updateSensorNumMap(std::shared_ptr<SensorNumMap>& sensorNumMap,
+                uint8_t& sensorNum, std::string& objPath,
+                sensorNumMapOption option = sensorNumMapOption::getSensorNumMapPtr)
+{
+    bool result = false;
     std::shared_ptr<SensorSubTree> sensorTree;
-    bool sensorTreeUpdated = details::getSensorSubtree(sensorTree);
+    static std::shared_ptr<SensorNumMap> s_sensorNumMap = nullptr;
+    static bool is_InProgess = false;
+
+
+    if (is_InProgess)
+    {
+        if constexpr (debug)
+        {
+            std::fprintf(stderr, "[%s] SensorNumMap is in updating...\n", __func__);
+        }
+        return result;
+    }
+    // check should refresh sensorNumMap
+    if (is_SensorNumMapReset)
+    {
+        if constexpr (debug)
+        {
+            std::fprintf(stderr, "[%s] Refreshing...\n", __func__);
+        }
+        s_sensorNumMap.reset();
+        option = sensorNumMapOption::update_full;
+    }
 
+    /* To be efficient, we only do full scan at first time.
+     * If there is any sensor info not found,
+     * we will update it individually later.
+     */
+    if (option == sensorNumMapOption::getSensorNumMapPtr && s_sensorNumMap)
+    {
+        sensorNumMap = s_sensorNumMap;
+        result = true;
+        return result;
+    }
+
+    is_InProgess = true;
+
+    bool sensorTreeUpdated = details::getSensorSubtree(sensorTree);
     if (!sensorTree) 
     {
-        return sensorNumMapUpated; //false;
+        is_InProgess = false;
+        return result; //false;
     }
 
     sd_bus* bus = NULL;
     int ret = sd_bus_default_system(&bus);
     if (ret < 0)
     {
-        return sensorNumMapUpated; //false;
+        is_InProgess = false;
+        return result; //false;
     }
 
     sdbusplus::bus::bus dbus(bus);
 
-    uint16_t sensorNum = 0;
-    uint16_t sensorIndex = 0;
-    for (const auto& sensor : *sensorTree)
+    if (!s_sensorNumMap)
     {
-        try
-        {
-            connection = sensor.second.begin()->first;
-            path = sensor.first;
-
-            if constexpr (debug)
-            {
-                std::fprintf(stderr, "[getSensorNumMap] OBJ_PATH: %s, SERVICE: %s\n", path.c_str(), connection.c_str());
-            }
-
-            auto methodCall = dbus.new_method_call(connection.c_str(), path.c_str(), propIntf, "Get");
-            methodCall.append(ipmiInterface, sensorNumProp);
+        s_sensorNumMap = std::make_shared<SensorNumMap>();
+    }
 
-            auto reply = dbus.call(methodCall);
-            if (reply.is_method_error())
+    if (option == sensorNumMapOption::update_ByPath)
+    {
+        auto found = sensorTree->find(objPath);
+        if (found != sensorTree->end())
+        {
+            result = _updateSensorNumMap(*found, dbus, sensorNum, objPath, s_sensorNumMap);
+        }
+    }
+    else
+    {
+        for (auto& sensor : *sensorTree)
+        {
+            uint8_t _sensorNum;
+            bool is_ok = _updateSensorNumMap(sensor, dbus, _sensorNum, objPath, s_sensorNumMap);
+            if (option == sensorNumMapOption::update_ByNum && _sensorNum == sensorNum)
             {
-                std::fprintf(stderr, "[getSensorNumMap] Method call reply fail\n");
-                return sensorNumMapUpated; //false;
+                result = is_ok;
+                break;
             }
-
-            reply.read(sn);
-            sensorNumber = static_cast<uint8_t>(std::get<uint64_t>(sn));
-            sensorNumMapPtr->insert(
-                SensorNumMap::value_type(sensorNumber, path));
         }
-        catch (std::exception &)
+
+        if (option == sensorNumMapOption::update_full)
         {
-            std::fprintf(stderr, "[getSensorNumMap] Get Sensor Map Fail\n");
-            return sensorNumMapUpated; //false;
+            // If we do full update, just let the result is true
+            // If there is any sensor info not found, we will update it individually later
+            result = true;
         }
     }
 
-    sensorNumMap = sensorNumMapPtr;
-    sensorNumMapUpated = true;
-    return sensorNumMapUpated;
+    sensorNumMap = s_sensorNumMap;
+
+    if (is_SensorNumMapReset)
+    {
+        is_SensorNumMapReset = false;
+    }
+    is_InProgess = false;
+
+    return result;
+}
+
+inline static bool getSensorNumMap(std::shared_ptr<SensorNumMap>& sensorNumMap)
+{
+    std::string path;
+    uint8_t sensorNumber;
+
+    return updateSensorNumMap(sensorNumMap, sensorNumber, path, sensorNumMapOption::getSensorNumMapPtr);
+}
+
+/* @brief To update SensorNumMap individually by sensorNum
+ * @param[in] sensorNumMap - a ptr to point at s_sensorNumMap
+ * @param[in] sensorNum - the sensor number
+ * @param[out] objPath - the obj path of the sensor
+ * @return bool - to indicate the result
+*/
+inline static bool tryGetPathBySensorNum(std::shared_ptr<SensorNumMap>& sensorNumMap,
+                                            uint8_t sensorNum, std::string& objPath)
+{
+    bool ret = updateSensorNumMap(sensorNumMap, sensorNum, objPath, sensorNumMapOption::update_ByNum);
+
+    if (!ret)
+    {
+        objPath = std::string();
+    }
+    if constexpr (debug)
+    {
+        std::fprintf(stderr, "[%s] sensor(#0x%x), obj path:%s\n", __func__, sensorNum, objPath.c_str());
+    }
+
+    return ret;
+}
+
+/* @brief To update SensorNumMap individually by obj path
+ * @param[in] sensorNumMap - a ptr to point at s_sensorNumMap
+ * @param[in] objPath - the obj path of the sensor
+ * @param[out] sensorNum - the sensor number
+ * @return bool - to indicate the result
+*/
+inline static bool tryGetSensorNumByPath(std::shared_ptr<SensorNumMap>& sensorNumMap,
+                                            std::string objPath, uint8_t& sensorNum)
+{
+    bool ret = updateSensorNumMap(sensorNumMap, sensorNum, objPath, sensorNumMapOption::update_ByPath);
+
+    if (!ret)
+    {
+        sensorNum = 0xFF;
+    }
+    if constexpr (debug)
+    {
+        std::fprintf(stderr, "[%s] sensor(#0x%x), obj path:%s\n", __func__, sensorNum, objPath.c_str());
+    }
+    return ret;
 }
 } // namespace details
 
@@ -280,8 +470,15 @@ inline static uint16_t getSensorNumberFromPath(const std::string& path)
     }
     catch (std::out_of_range& e)
     {
-        phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
-        return invalidSensorNumber;
+        // phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+        uint8_t sensorNum;
+        bool ret = details::tryGetSensorNumByPath(sensorNumMapPtr, path, sensorNum);
+        if (debug && !ret)
+        {
+            phosphor::logging::log<phosphor::logging::level::ERR>("Failed to get sensor number");
+        }
+
+        return sensorNum;
     }
 }
 
@@ -349,8 +546,15 @@ inline static std::string getPathFromSensorNumber(uint16_t sensorNum)
     }
     catch (std::out_of_range& e)
     {
-        phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
-        return std::string();
+        // phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+        //try to git it from dbus
+        std::string objPath;
+        bool ret = details::tryGetPathBySensorNum(sensorNumMapPtr, sensorNum, objPath);
+        if (debug && !ret)
+        {
+            phosphor::logging::log<phosphor::logging::level::ERR>("Failed to get sensor objPath");
+        }
+        return objPath;
     }
 }
 
-- 
2.7.4

