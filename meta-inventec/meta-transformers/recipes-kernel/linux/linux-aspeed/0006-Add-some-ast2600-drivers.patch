From acb4f509b918be7123e05c63ebd00443cbaa98c8 Mon Sep 17 00:00:00 2001
From: anonymous <anonymous@inventec.com>
Date: Tue, 27 Oct 2020 20:47:37 -0400
Subject: [PATCH 06/24] Add some ast2600 drivers

-ast2600 adc hwmon driver
-ast2600 pwm driver
-spi master driver
---
 drivers/hwmon/Kconfig                 |   11 +
 drivers/hwmon/Makefile                |    1 +
 drivers/hwmon/aspeed-pwm-tachometer.c | 1064 +++++++++++++++++++++++++++++++++
 drivers/iio/adc/aspeed_adc.c          |  103 +++-
 drivers/spi/Kconfig                   |    7 +
 drivers/spi/Makefile                  |    1 +
 drivers/spi/spi-aspeed.c              |  515 ++++++++++++++++
 7 files changed, 1689 insertions(+), 13 deletions(-)
 create mode 100755 drivers/hwmon/aspeed-pwm-tachometer.c
 create mode 100644 drivers/spi/spi-aspeed.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 66d360c..c1d412b 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -400,6 +400,17 @@ config SENSORS_ASPEED
 	  This driver can also be built as a module. If so, the module
 	  will be called aspeed_pwm_tacho.
 
+config SENSORS_ASPEED_PWM_TECHOMETER
+        tristate "ASPEED AST2600 PWM and Fan tach driver"
+        depends on THERMAL || THERMAL=y
+        select REGMAP
+        help
+          This driver provides support for ASPEED AST2600 PWM
+          and Fan Tacho controllers.
+
+          This driver can also be built as a module. If so, the module
+          will be called aspeed-pwm-tachometer.
+
 config SENSORS_ATXP1
 	tristate "Attansic ATXP1 VID controller"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index c20c7c5..52ba6a7 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_SENSORS_ARM_SCPI)	+= scpi-hwmon.o
 obj-$(CONFIG_SENSORS_AS370)	+= as370-hwmon.o
 obj-$(CONFIG_SENSORS_ASC7621)	+= asc7621.o
 obj-$(CONFIG_SENSORS_ASPEED)	+= aspeed-pwm-tacho.o
+obj-$(CONFIG_SENSORS_ASPEED_PWM_TECHOMETER)     += aspeed-pwm-tachometer.o
 obj-$(CONFIG_SENSORS_ATXP1)	+= atxp1.o
 obj-$(CONFIG_SENSORS_AXI_FAN_CONTROL) += axi-fan-control.o
 obj-$(CONFIG_SENSORS_BT1_PVT)	+= bt1-pvt.o
diff --git a/drivers/hwmon/aspeed-pwm-tachometer.c b/drivers/hwmon/aspeed-pwm-tachometer.c
new file mode 100755
index 0000000..1af24ca
--- /dev/null
+++ b/drivers/hwmon/aspeed-pwm-tachometer.c
@@ -0,0 +1,1064 @@
+/*
+ * Copyright (C) ASPEED Technology Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 or later as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/reset.h>
+#include <linux/regmap.h>
+#include <linux/thermal.h>
+
+#define ASPEED_PWM_CTRL			0x00	//PWM0 General Register
+#define ASPEED_PWM_CTRL_CH(x)		((x * 0x10) + 0x00)
+#define  PWM_LOAD_AS_WDT			BIT(19)	//load selection as WDT
+#define  PWM_DUTY_LOAD_AS_WDT_EN	BIT(18)	//enable PWM duty load as WDT
+#define  PWM_DUTY_SYNC_DIS			BIT(17)	//disable PWM duty sync
+#define	 PWM_CLK_ENABLE				BIT(16)	//enable PWM clock
+#define  PWM_LEVEL_OUTPUT			BIT(15)	//output PWM level
+#define  PWM_INVERSE				BIT(14) //inverse PWM pin
+#define  PWM_OPEN_DRAIN_EN			BIT(13)	//enable open-drain
+#define  PWM_PIN_EN					BIT(12) //enable PWM pin
+#define  PWM_CLK_DIV_H_MASK			(0xf << 8)	//PWM clock division H bit [3:0]
+#define  PWM_CLK_DIV_L_MASK			(0xff)	//PWM clock division H bit [3:0]
+
+/*
+\xregmid {11:8 }{RW}{PWM clock division H bit [3:0]}{
+                     0: divide 1 \n
+                     1: divide 2 \n
+                     2: divide 4 \n
+                     3: divide 8 \n
+                     ... \n
+                     F: divide 32768}
+\xregmid {7 :0 }{RW}{PWM clock division L bit [7:0]}{
+                     00: divide 1 \n
+                     01: divide 2 \n
+                     02: divide 3 \n
+                     03: divide 4 \n
+                     ... \n
+                     FF: divide 256}
+*/
+
+#define ASPEED_PWM_DUTY_CYCLE		0x04	//PWM0 Duty Cycle Register
+#define ASPEED_PWM_DUTY_CYCLE_CH(x)		((x * 0x10) + 0x04)
+#define  PWM_LOOP_BIT_MASK				(0xf << 24)	//loop bit [7:0]
+#define  PWM_PERIOD_BIT					(24)	//pwm period bit [7:0]
+#define  PWM_PERIOD_BIT_MASK			(0xff << 24)	//pwm period bit [7:0]
+#define  PWM_RISING_FALLING_AS_WDT_BIT  (16)
+#define  PWM_RISING_FALLING_AS_WDT_MASK (0xff << 16)	//pwm rising/falling point bit [7:0] as WDT
+#define  PWM_RISING_FALLING_MASK		(0xffff)
+#define  PWM_RISING_FALLING_BIT			(8)	//pwm falling point bit [7:0]
+#define  PWM_RISING_RISING_BIT			(0)	//pwm rising point bit [7:0]
+
+#define  DEF_PWM_PERIOD 0xff
+
+
+#define ASPEED_TECHO_CTRL		0x08	//TACH0 General Register
+#define ASPEED_TECHO_CTRL_CH(x)			((x * 0x10) + 0x08)
+#define  TECHO_IER						BIT(31)	//enable tacho interrupt
+#define  TECHO_INVERS_LIMIT				BIT(30) //inverse tacho limit comparison
+#define  TECHO_LOOPBACK					BIT(29) //tacho loopback
+#define  TECHO_ENABLE					BIT(28)	//{enable tacho}
+#define  TECHO_DEBOUNCE_BIT				(26) //{tacho de-bounce}
+#define  TECHO_DEBOUNCE_MASK			(0x3 << 26) //{tacho de-bounce}
+#define  TECHIO_EDGE_MASK				(0x3 << 24) //tacho edge}
+#define  TECHIO_EDGE_BIT				(24) //tacho edge}
+#define  TECHO_CLK_DIV_T_MASK			(0xf << 20)
+#define  TECHO_CLK_DIV_BIT				(20)
+#define  TECHO_THRESHOLD_MASK			(0xfffff)	//tacho threshold bit
+/*
+\xregmid {23:20}{RW}{tacho clock division T bit [3:0]}{
+                     0: divide 1 \n
+                     1: divide 4 \n
+                     2: divide 16 \n
+                     3: divide 64 \n
+                     ... \n
+                     B: divide 4194304 \n
+					 others: reserved}
+\xregmidb{19 :0 }{RW}{tacho threshold bit [19:0]}
+*/
+
+#define ASPEED_TECHO_STS		0x0C	//TACH0 Status Register
+#define ASPEED_TECHO_STS_CH(x)			((x * 0x10) + 0x0C)
+#define  TECHO_ISR			BIT(31)	//interrupt status and clear
+#define  PWM_OUT			BIT(25)	//{pwm_out}
+#define  PWM_OEN			BIT(24)	//{pwm_oeN}
+#define  TACHO_DEB_INPUT	BIT(23)	//tacho deB input
+#define  TACHO_RAW_INPUT	BIT(22) //tacho raw input}
+#define  TACHO_VALUE_UPDATE	BIT(21)	//tacho value updated since the last read
+#define  TACHO_FULL_MEASUREMENT	BIT(20) //{tacho full measurement}
+#define  TACHO_VALUE_MASK	0xfffff	//tacho value bit [19:0]}
+
+#define MAX_CDEV_NAME_LEN 16
+
+struct aspeed_pwm_channel_params {
+	int target_freq;
+	int pwm_freq;
+	int load_wdt_rising_falling_pt;
+	int load_wdt_selection;		//0: rising , 1: falling
+	int load_wdt_enable;
+	int	duty_sync_enable;
+	int invert_pin;
+	u8	rising;
+	u8	falling;
+};
+
+static struct aspeed_pwm_channel_params default_pwm_params[] = {
+	[0] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 1,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+
+	},
+	[1] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[2] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[3] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[4] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[5] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[6] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[7] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[8] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[9] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[10] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[11] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[12] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[13] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[14] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+	[15] = {
+		.target_freq = 25000,
+		.load_wdt_rising_falling_pt = 0x10,
+		.load_wdt_selection = 0,
+		.load_wdt_enable = 0,
+		.duty_sync_enable = 0,
+		.invert_pin = 0,
+		.rising = 0x00,
+		.falling = 0x0a,
+	},
+};
+
+/*
+ * 5:4 fan tach edge mode selection bit:
+ * 00: falling
+ * 01: rising
+ * 10: both
+ * 11: reserved.
+ */
+
+#define F2F_EDGES 0x00 /* 10b */
+#define R2R_EDGES 0x01 /* 10b */
+#define BOTH_EDGES 0x02 /* 10b */
+
+struct aspeed_techo_channel_params {
+	u32 min_rpm;
+	int limited_inverse;
+	u16 threshold;
+	u8	tacho_edge;
+	u8	tacho_debounce;
+	u32	divide;
+};
+
+
+static struct aspeed_techo_channel_params default_techo_params[] = {
+	[0] = {
+		.min_rpm = 2900,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[1] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[2] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[3] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[4] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[5] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[6] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[7] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[8] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[9] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[10] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[11] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[12] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[13] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[14] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+	[15] = {
+		.min_rpm = 2000,
+		.limited_inverse = 0,
+		.threshold = 0,
+		.tacho_edge = F2F_EDGES,
+		.tacho_debounce = 0,
+		.divide = 8,
+	},
+};
+
+struct aspeed_pwm_tachometer_data {
+	struct regmap *regmap;
+	unsigned long clk_freq;
+	struct reset_control *reset;
+	bool pwm_present[16];
+	bool fan_tach_present[16];
+	struct aspeed_pwm_channel_params *pwm_channel;
+	struct aspeed_techo_channel_params *techo_channel;
+	struct aspeed_cooling_device *cdev[8];
+	const struct attribute_group *groups[3];
+};
+
+struct aspeed_cooling_device {
+	char name[16];
+	struct aspeed_pwm_tachometer_data *priv;
+	struct thermal_cooling_device *tcdev;
+	int pwm_channel;
+	u8 *cooling_levels;
+	u8 max_state;
+	u8 cur_state;
+};
+
+static int regmap_aspeed_pwm_tachometer_reg_write(void *context, unsigned int reg,
+					     unsigned int val)
+{
+	void __iomem *regs = (void __iomem *)context;
+
+	writel(val, regs + reg);
+	return 0;
+}
+
+static int regmap_aspeed_pwm_tachometer_reg_read(void *context, unsigned int reg,
+					    unsigned int *val)
+{
+	void __iomem *regs = (void __iomem *)context;
+
+	*val = readl(regs + reg);
+	return 0;
+}
+
+static const struct regmap_config aspeed_pwm_tachometer_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x100,
+	.reg_write = regmap_aspeed_pwm_tachometer_reg_write,
+	.reg_read = regmap_aspeed_pwm_tachometer_reg_read,
+	.fast_io = true,
+};
+
+static void aspeed_set_pwm_channel_enable(struct regmap *regmap, u8 pwm_channel,
+				       bool enable)
+{
+	regmap_update_bits(regmap, ASPEED_PWM_CTRL_CH(pwm_channel), (PWM_CLK_ENABLE | PWM_PIN_EN), enable ? (PWM_CLK_ENABLE | PWM_PIN_EN) : 0);
+}
+
+static void aspeed_set_fan_tach_ch_enable(struct aspeed_pwm_tachometer_data *priv, u8 fan_tach_ch,
+					  bool enable)
+{
+	u32 i = 0;
+	u32 divide_val = 0;
+	u32 target_div = 0;
+	u32 reg_value = 0;
+
+	if(enable) {
+		//4 ^ n
+//		printk("=== %ld \n", (priv->clk_freq * 60 / priv->techo_channel[fan_tach_ch].min_rpm * 2));
+		target_div = (priv->clk_freq * 60 / priv->techo_channel[fan_tach_ch].min_rpm * 2) / (0xfffff + 1);
+//		printk("min_rpm %d , target_div %d \n", priv->techo_channel[fan_tach_ch].min_rpm, target_div);
+		if(target_div) {
+			for(i = 0; i < 12; i++) {
+				divide_val = BIT(i) * BIT(i);
+				if(divide_val > target_div)
+					break;
+
+			}
+		} else {
+			i = 0;
+			divide_val = 1;
+		}
+		priv->techo_channel[fan_tach_ch].divide = divide_val;
+//		printk("i : %d ,target_div %d, divide_val %d, priv->clk_freq/divide_val %ld ", i, target_div, divide_val, priv->clk_freq/divide_val);
+
+		reg_value = TECHO_ENABLE |
+				(priv->techo_channel[fan_tach_ch].tacho_edge << TECHIO_EDGE_BIT) |
+				(i << TECHO_CLK_DIV_BIT) |
+				(priv->techo_channel[fan_tach_ch].tacho_debounce << TECHO_DEBOUNCE_BIT);
+
+		if(priv->techo_channel[fan_tach_ch].limited_inverse)
+			reg_value |= TECHO_INVERS_LIMIT;
+
+		if(priv->techo_channel[fan_tach_ch].threshold)
+			reg_value |= (TECHO_IER | priv->techo_channel[fan_tach_ch].threshold);
+
+		regmap_write(priv->regmap, ASPEED_TECHO_CTRL_CH(fan_tach_ch), reg_value);
+	} else
+		regmap_update_bits(priv->regmap, ASPEED_TECHO_CTRL_CH(fan_tach_ch),  TECHO_ENABLE, 0);
+}
+
+/*
+ * The PWM frequency = HCLK(200Mhz) / (clock division L bit *
+ * clock division H bit * (period bit + 1))
+ */
+static void aspeed_set_pwm_channel_fan_ctrl(struct aspeed_pwm_tachometer_data *priv,
+					 u8 index, u8 fan_ctrl)
+{
+	u32 duty_value,	ctrl_value;
+	u32 div_h, div_l, cal_freq;
+
+	if (fan_ctrl == 0) {
+		aspeed_set_pwm_channel_enable(priv->regmap, index, false);
+	} else {
+		cal_freq = priv->clk_freq / (DEF_PWM_PERIOD + 1);
+		//calculate for target frequence
+		for(div_l = 0; div_l < 0x100; div_l++) {
+			for(div_h = 0; div_h < 0x10; div_h++) {
+//				printk("div h %x, l : %x , freq %ld \n", div_h, div_l, (cal_freq / (BIT(div_h) * (div_l + 1))));
+				if((cal_freq / (BIT(div_h) * (div_l + 1))) < priv->pwm_channel[index].target_freq)
+					break;
+			}
+			if((cal_freq / (BIT(div_h) * (div_l + 1))) < priv->pwm_channel[index].target_freq)
+				break;
+		}
+
+		priv->pwm_channel[index].pwm_freq = cal_freq / (BIT(div_h) * (div_l + 1));
+//		printk("div h %x, l : %x pwm out clk %d \n", div_h, div_l, priv->pwm_channel[index].pwm_freq);
+//		printk("hclk %ld, target pwm freq %d, real pwm freq %d\n", priv->clk_freq, priv->pwm_channel[index].target_freq, priv->pwm_channel[index].pwm_freq);
+
+		ctrl_value = (div_h << 8) | div_l;
+
+		duty_value = (DEF_PWM_PERIOD << PWM_PERIOD_BIT) |
+					(0 << PWM_RISING_RISING_BIT) | (fan_ctrl << PWM_RISING_FALLING_BIT);
+
+		if (priv->pwm_channel[index].load_wdt_enable) {
+			ctrl_value |= PWM_DUTY_LOAD_AS_WDT_EN;
+			if(priv->pwm_channel[index].load_wdt_selection) {
+				ctrl_value |= PWM_LOAD_AS_WDT;
+				duty_value |= (priv->pwm_channel[index].load_wdt_rising_falling_pt << PWM_RISING_FALLING_AS_WDT_BIT);
+			} else {
+				duty_value |= (priv->pwm_channel[index].load_wdt_rising_falling_pt << PWM_RISING_FALLING_AS_WDT_BIT);
+			}
+		}
+
+		regmap_write(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), duty_value);
+		regmap_write(priv->regmap, ASPEED_PWM_CTRL_CH(index), ctrl_value);
+
+		aspeed_set_pwm_channel_enable(priv->regmap, index, true);
+	}
+}
+
+static int aspeed_get_fan_tach_ch_rpm(struct aspeed_pwm_tachometer_data *priv,
+				      u8 fan_tach_ch)
+{
+	u32 raw_data, tach_div, clk_source, val;
+	u8 two_plus = 2;
+	int i, retries = 3;
+
+	for(i = 0; i < retries; i++) {
+		regmap_read(priv->regmap, ASPEED_TECHO_STS_CH(fan_tach_ch), &val);
+		if (TACHO_FULL_MEASUREMENT & val)
+			break;
+	}
+
+	raw_data = val & TACHO_VALUE_MASK;
+	if(raw_data == 0xfffff)
+		return 0;
+
+	raw_data += 1;
+
+	/*
+	 * We need the mode to determine if the raw_data is double (from
+	 * counting both edges).
+	 */
+	tach_div = raw_data * (priv->techo_channel[fan_tach_ch].divide) * (two_plus);
+
+//	printk("clk %ld, raw_data %d , tach_div %d  \n", priv->clk_freq, raw_data, tach_div);
+
+	clk_source = priv->clk_freq;
+
+	if (raw_data == 0)
+		return 0;
+
+	return ((clk_source / tach_div) * 60);
+
+}
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	int ret;
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+	long fan_ctrl;
+	u8 org_falling = priv->pwm_channel[index].falling;
+
+	ret = kstrtol(buf, 10, &fan_ctrl);
+	if (ret != 0)
+		return ret;
+
+	if (fan_ctrl < 0 || fan_ctrl > DEF_PWM_PERIOD)
+		return -EINVAL;
+
+	if (priv->pwm_channel[index].falling == fan_ctrl)
+		return count;
+
+	priv->pwm_channel[index].falling = fan_ctrl;
+
+	if(fan_ctrl == 0)
+		aspeed_set_pwm_channel_enable(priv->regmap, index, false);
+	else
+		regmap_update_bits(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), GENMASK(15, 8), (fan_ctrl << PWM_RISING_FALLING_BIT));
+
+	if(org_falling == 0)
+		aspeed_set_pwm_channel_enable(priv->regmap, index, true);
+
+	return count;
+}
+
+static ssize_t show_pwm(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", priv->pwm_channel[index].falling);
+}
+
+static ssize_t show_rpm(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	int rpm;
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	rpm = aspeed_get_fan_tach_ch_rpm(priv, index);
+	if (rpm < 0)
+		return rpm;
+
+	return sprintf(buf, "%d\n", rpm);
+}
+
+static umode_t pwm_is_visible(struct kobject *kobj,
+			      struct attribute *a, int index)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	if (!priv->pwm_present[index])
+		return 0;
+	return a->mode;
+}
+
+static umode_t fan_dev_is_visible(struct kobject *kobj,
+				  struct attribute *a, int index)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	if (!priv->fan_tach_present[index])
+		return 0;
+	return a->mode;
+}
+
+static SENSOR_DEVICE_ATTR(pwm0, 0644,
+			show_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm1, 0644,
+			show_pwm, set_pwm, 1);
+static SENSOR_DEVICE_ATTR(pwm2, 0644,
+			show_pwm, set_pwm, 2);
+static SENSOR_DEVICE_ATTR(pwm3, 0644,
+			show_pwm, set_pwm, 3);
+static SENSOR_DEVICE_ATTR(pwm4, 0644,
+			show_pwm, set_pwm, 4);
+static SENSOR_DEVICE_ATTR(pwm5, 0644,
+			show_pwm, set_pwm, 5);
+static SENSOR_DEVICE_ATTR(pwm6, 0644,
+			show_pwm, set_pwm, 6);
+static SENSOR_DEVICE_ATTR(pwm7, 0644,
+			show_pwm, set_pwm, 7);
+#if 0
+static SENSOR_DEVICE_ATTR(pwm8, 0644,
+			show_pwm, set_pwm, 8);
+static SENSOR_DEVICE_ATTR(pwm9, 0644,
+			show_pwm, set_pwm, 9);
+static SENSOR_DEVICE_ATTR(pwm10, 0644,
+			show_pwm, set_pwm, 10);
+static SENSOR_DEVICE_ATTR(pwm11, 0644,
+			show_pwm, set_pwm, 11);
+static SENSOR_DEVICE_ATTR(pwm12, 0644,
+			show_pwm, set_pwm, 12);
+static SENSOR_DEVICE_ATTR(pwm13, 0644,
+			show_pwm, set_pwm, 13);
+static SENSOR_DEVICE_ATTR(pwm14, 0644,
+			show_pwm, set_pwm, 14);
+static SENSOR_DEVICE_ATTR(pwm15, 0644,
+			show_pwm, set_pwm, 15);
+#endif
+static struct attribute *pwm_dev_attrs[] = {
+	&sensor_dev_attr_pwm0.dev_attr.attr,
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm2.dev_attr.attr,
+	&sensor_dev_attr_pwm3.dev_attr.attr,
+	&sensor_dev_attr_pwm4.dev_attr.attr,
+	&sensor_dev_attr_pwm5.dev_attr.attr,
+	&sensor_dev_attr_pwm6.dev_attr.attr,
+	&sensor_dev_attr_pwm7.dev_attr.attr,
+#if 0
+	&sensor_dev_attr_pwm8.dev_attr.attr,
+	&sensor_dev_attr_pwm9.dev_attr.attr,
+	&sensor_dev_attr_pwm10.dev_attr.attr,
+	&sensor_dev_attr_pwm11.dev_attr.attr,
+	&sensor_dev_attr_pwm12.dev_attr.attr,
+	&sensor_dev_attr_pwm13.dev_attr.attr,
+	&sensor_dev_attr_pwm14.dev_attr.attr,
+	&sensor_dev_attr_pwm15.dev_attr.attr,
+#endif
+	NULL,
+};
+
+static const struct attribute_group pwm_dev_group = {
+	.attrs = pwm_dev_attrs,
+	.is_visible = pwm_is_visible,
+};
+
+static SENSOR_DEVICE_ATTR(fan0_input, 0444,
+		show_rpm, NULL, 0);
+static SENSOR_DEVICE_ATTR(fan1_input, 0444,
+		show_rpm, NULL, 1);
+static SENSOR_DEVICE_ATTR(fan2_input, 0444,
+		show_rpm, NULL, 2);
+static SENSOR_DEVICE_ATTR(fan3_input, 0444,
+		show_rpm, NULL, 3);
+static SENSOR_DEVICE_ATTR(fan4_input, 0444,
+		show_rpm, NULL, 4);
+static SENSOR_DEVICE_ATTR(fan5_input, 0444,
+		show_rpm, NULL, 5);
+static SENSOR_DEVICE_ATTR(fan6_input, 0444,
+		show_rpm, NULL, 6);
+static SENSOR_DEVICE_ATTR(fan7_input, 0444,
+		show_rpm, NULL, 7);
+static SENSOR_DEVICE_ATTR(fan8_input, 0444,
+		show_rpm, NULL, 8);
+static SENSOR_DEVICE_ATTR(fan9_input, 0444,
+		show_rpm, NULL, 9);
+static SENSOR_DEVICE_ATTR(fan10_input, 0444,
+		show_rpm, NULL, 10);
+static SENSOR_DEVICE_ATTR(fan11_input, 0444,
+		show_rpm, NULL, 11);
+static SENSOR_DEVICE_ATTR(fan12_input, 0444,
+		show_rpm, NULL, 12);
+static SENSOR_DEVICE_ATTR(fan13_input, 0444,
+		show_rpm, NULL, 13);
+static SENSOR_DEVICE_ATTR(fan14_input, 0444,
+		show_rpm, NULL, 14);
+static SENSOR_DEVICE_ATTR(fan15_input, 0444,
+		show_rpm, NULL, 15);
+static struct attribute *fan_dev_attrs[] = {
+	&sensor_dev_attr_fan0_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan4_input.dev_attr.attr,
+	&sensor_dev_attr_fan5_input.dev_attr.attr,
+	&sensor_dev_attr_fan6_input.dev_attr.attr,
+	&sensor_dev_attr_fan7_input.dev_attr.attr,
+	&sensor_dev_attr_fan8_input.dev_attr.attr,
+	&sensor_dev_attr_fan9_input.dev_attr.attr,
+	&sensor_dev_attr_fan10_input.dev_attr.attr,
+	&sensor_dev_attr_fan11_input.dev_attr.attr,
+	&sensor_dev_attr_fan12_input.dev_attr.attr,
+	&sensor_dev_attr_fan13_input.dev_attr.attr,
+	&sensor_dev_attr_fan14_input.dev_attr.attr,
+	&sensor_dev_attr_fan15_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group fan_dev_group = {
+	.attrs = fan_dev_attrs,
+	.is_visible = fan_dev_is_visible,
+};
+
+static void aspeed_create_pwm_channel(struct aspeed_pwm_tachometer_data *priv,
+				   u8 pwm_channel)
+{
+	priv->pwm_present[pwm_channel] = true;
+
+	//use default
+	aspeed_set_pwm_channel_fan_ctrl(priv, pwm_channel, priv->pwm_channel[pwm_channel].falling);
+}
+
+static void aspeed_create_fan_tach_channel(struct aspeed_pwm_tachometer_data *priv,
+					   u8 *fan_tach_ch, int count, u32 min_rpm)
+{
+	u8 val, index;
+
+	for (val = 0; val < count; val++) {
+		index = fan_tach_ch[val];
+		priv->fan_tach_present[index] = true;
+		priv->techo_channel[index].min_rpm = min_rpm;
+		aspeed_set_fan_tach_ch_enable(priv, index, true);
+	}
+}
+
+static int
+aspeed_pwm_cz_get_max_state(struct thermal_cooling_device *tcdev,
+			    unsigned long *state)
+{
+	struct aspeed_cooling_device *cdev = tcdev->devdata;
+
+	*state = cdev->max_state;
+
+	return 0;
+}
+
+static int
+aspeed_pwm_cz_get_cur_state(struct thermal_cooling_device *tcdev,
+			    unsigned long *state)
+{
+	struct aspeed_cooling_device *cdev = tcdev->devdata;
+
+	*state = cdev->cur_state;
+
+	return 0;
+}
+
+static int
+aspeed_pwm_cz_set_cur_state(struct thermal_cooling_device *tcdev,
+			    unsigned long state)
+{
+	struct aspeed_cooling_device *cdev = tcdev->devdata;
+
+	if (state > cdev->max_state)
+		return -EINVAL;
+
+	cdev->cur_state = state;
+	cdev->priv->pwm_channel[cdev->pwm_channel].falling =
+					cdev->cooling_levels[cdev->cur_state];
+	aspeed_set_pwm_channel_fan_ctrl(cdev->priv, cdev->pwm_channel,
+				     cdev->cooling_levels[cdev->cur_state]);
+
+	return 0;
+}
+
+static const struct thermal_cooling_device_ops aspeed_pwm_cool_ops = {
+	.get_max_state = aspeed_pwm_cz_get_max_state,
+	.get_cur_state = aspeed_pwm_cz_get_cur_state,
+	.set_cur_state = aspeed_pwm_cz_set_cur_state,
+};
+
+static int aspeed_create_pwm_cooling(struct device *dev,
+				     struct device_node *child,
+				     struct aspeed_pwm_tachometer_data *priv,
+				     u32 pwm_channel, u8 num_levels)
+{
+	int ret;
+	struct aspeed_cooling_device *cdev;
+
+	cdev = devm_kzalloc(dev, sizeof(*cdev), GFP_KERNEL);
+	if (!cdev)
+		return -ENOMEM;
+
+	cdev->cooling_levels = devm_kzalloc(dev, num_levels, GFP_KERNEL);
+	if (!cdev->cooling_levels)
+		return -ENOMEM;
+
+	cdev->max_state = num_levels - 1;
+	ret = of_property_read_u8_array(child, "cooling-levels",
+					cdev->cooling_levels,
+					num_levels);
+	if (ret) {
+		dev_err(dev, "Property 'cooling-levels' cannot be read.\n");
+		return ret;
+	}
+	snprintf(cdev->name, MAX_CDEV_NAME_LEN, "%s%d", child->name, pwm_channel);
+
+	cdev->tcdev = thermal_of_cooling_device_register(child,
+							 cdev->name,
+							 cdev,
+							 &aspeed_pwm_cool_ops);
+	if (IS_ERR(cdev->tcdev))
+		return PTR_ERR(cdev->tcdev);
+
+	cdev->priv = priv;
+	cdev->pwm_channel = pwm_channel;
+
+	priv->cdev[pwm_channel] = cdev;
+
+	return 0;
+}
+
+#define DEFAULT_TARGET_PWM_FREQ		25000
+#define DEFAULT_MIN_RPM				2900
+
+static int aspeed_pwm_create_fan(struct device *dev,
+			     struct device_node *child,
+			     struct aspeed_pwm_tachometer_data *priv)
+{
+	u8 *fan_tach_ch;
+	u32 fan_min_rpm = 0;
+	u32 pwm_channel;
+	u32 target_pwm_freq = 0;
+	int ret, count;
+
+	ret = of_property_read_u32(child, "reg", &pwm_channel);
+	if (ret)
+
+		return ret;
+
+	ret = of_property_read_u32(child, "aspeed,target_pwm", &target_pwm_freq);
+	if (ret)
+		target_pwm_freq = DEFAULT_TARGET_PWM_FREQ;
+
+	aspeed_create_pwm_channel(priv, (u8)pwm_channel);
+	ret = of_property_count_u8_elems(child, "cooling-levels");
+	if (ret > 0) {
+		ret = aspeed_create_pwm_cooling(dev, child, priv, pwm_channel,
+						ret);
+		if (ret)
+			return ret;
+	}
+
+	count = of_property_count_u8_elems(child, "aspeed,fan-tach-ch");
+	if (count < 1)
+		return -EINVAL;
+
+	fan_tach_ch = devm_kzalloc(dev, sizeof(*fan_tach_ch) * count,
+				   GFP_KERNEL);
+	if (!fan_tach_ch)
+		return -ENOMEM;
+	ret = of_property_read_u8_array(child, "aspeed,fan-tach-ch",
+					fan_tach_ch, count);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(child, "aspeed,min_rpm", &fan_min_rpm);
+	if (ret)
+		fan_min_rpm = DEFAULT_MIN_RPM;
+
+	aspeed_create_fan_tach_channel(priv, fan_tach_ch, count, fan_min_rpm);
+
+	return 0;
+}
+
+static int aspeed_pwm_tachometer_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np, *child;
+	struct aspeed_pwm_tachometer_data *priv;
+	void __iomem *regs;
+	struct resource *res;
+	struct device *hwmon;
+	struct clk *clk;
+	int ret;
+
+	np = dev->of_node;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOENT;
+	regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pwm_channel = default_pwm_params;
+	priv->techo_channel = default_techo_params;
+	priv->regmap = devm_regmap_init(dev, NULL, (__force void *)regs,
+			&aspeed_pwm_tachometer_regmap_config);
+
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(clk))
+		return -ENODEV;
+	priv->clk_freq = clk_get_rate(clk);
+
+	priv->reset = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->reset)) {
+		dev_err(&pdev->dev, "can't get aspeed_pwm_tacho reset\n");
+		return PTR_ERR(priv->reset);
+	}
+
+	//scu init
+	reset_control_assert(priv->reset);
+	reset_control_deassert(priv->reset);
+
+	for_each_child_of_node(np, child) {
+		ret = aspeed_pwm_create_fan(dev, child, priv);
+		if (ret) {
+			of_node_put(child);
+			return ret;
+		}
+	}
+
+	priv->groups[0] = &pwm_dev_group;
+	priv->groups[1] = &fan_dev_group;
+	priv->groups[2] = NULL;
+	hwmon = devm_hwmon_device_register_with_groups(dev,
+						       "aspeed_pwm_tachometer",
+						       priv, priv->groups);
+	return PTR_ERR_OR_ZERO(hwmon);
+}
+
+static const struct of_device_id of_pwm_tachometer_match_table[] = {
+	{ .compatible = "aspeed,ast2600-pwm-tachometer", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_pwm_tachometer_match_table);
+
+static struct platform_driver aspeed_pwm_tachometer_driver = {
+	.probe		= aspeed_pwm_tachometer_probe,
+	.driver		= {
+		.name	= "aspeed_pwm_tachometer",
+		.of_match_table = of_pwm_tachometer_match_table,
+	},
+};
+
+module_platform_driver(aspeed_pwm_tachometer_driver);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_DESCRIPTION("ASPEED PWM and Fan Tachometer device driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/aspeed_adc.c b/drivers/iio/adc/aspeed_adc.c
index 19efaa4..9c138c9 100644
--- a/drivers/iio/adc/aspeed_adc.c
+++ b/drivers/iio/adc/aspeed_adc.c
@@ -1,8 +1,12 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Aspeed AST2400/2500 ADC
+ * Aspeed AST2400/2500/2600 ADC
  *
  * Copyright (C) 2017 Google, Inc.
+ * Copyright (C) ASPEED Technology Inc.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
  */
 
 #include <linux/clk.h>
@@ -30,6 +34,14 @@
 #define ASPEED_REG_CLOCK_CONTROL	0x0C
 #define ASPEED_REG_MAX			0xC0
 
+//ast2600
+#define REF_VLOTAGE_2500mV 		0
+#define REF_VLOTAGE_1200mV 		(1 << 6)
+#define REF_VLOTAGE_1550mV 		(2 << 6)
+#define REF_VLOTAGE_900mV 		(3 << 6)
+
+#define ASPEED_AUTOPENSATING		BIT(5)
+
 #define ASPEED_OPERATION_MODE_POWER_DOWN	(0x0 << 1)
 #define ASPEED_OPERATION_MODE_STANDBY		(0x1 << 1)
 #define ASPEED_OPERATION_MODE_NORMAL		(0x7 << 1)
@@ -45,8 +57,10 @@ struct aspeed_adc_model_data {
 	const char *model_name;
 	unsigned int min_sampling_rate;	// Hz
 	unsigned int max_sampling_rate;	// Hz
-	unsigned int vref_voltage;	// mV
+	u32 vref_voltage;	// mV
 	bool wait_init_sequence;
+	struct iio_chan_spec const	*channels;
+	int num_channels;
 };
 
 struct aspeed_adc_data {
@@ -56,6 +70,7 @@ struct aspeed_adc_data {
 	struct clk_hw		*clk_prescaler;
 	struct clk_hw		*clk_scaler;
 	struct reset_control	*rst;
+	int 				cv;
 };
 
 #define ASPEED_CHAN(_idx, _data_reg_addr) {			\
@@ -87,6 +102,17 @@ static const struct iio_chan_spec aspeed_adc_iio_channels[] = {
 	ASPEED_CHAN(15, 0x2E),
 };
 
+static const struct iio_chan_spec ast2600_adc_iio_channels[] = {
+	ASPEED_CHAN(0, 0x10),
+	ASPEED_CHAN(1, 0x12),
+	ASPEED_CHAN(2, 0x14),
+	ASPEED_CHAN(3, 0x16),
+	ASPEED_CHAN(4, 0x18),
+	ASPEED_CHAN(5, 0x1A),
+	ASPEED_CHAN(6, 0x1C),
+	ASPEED_CHAN(7, 0x1E),
+};
+
 static int aspeed_adc_read_raw(struct iio_dev *indio_dev,
 			       struct iio_chan_spec const *chan,
 			       int *val, int *val2, long mask)
@@ -173,8 +199,12 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 	struct iio_dev *indio_dev;
 	struct aspeed_adc_data *data;
 	const struct aspeed_adc_model_data *model_data;
+	struct resource *res;
 	const char *clk_parent_name;
+	char prescaler_clk_name[32];
+	char scaler_clk_name[32];
 	int ret;
+	u32 eng_ctrl = 0;
 	u32 adc_engine_control_reg_val;
 
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data));
@@ -184,7 +214,8 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 	data = iio_priv(indio_dev);
 	data->dev = &pdev->dev;
 
-	data->base = devm_platform_ioremap_resource(pdev, 0);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(data->base))
 		return PTR_ERR(data->base);
 
@@ -192,19 +223,21 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 	spin_lock_init(&data->clk_lock);
 	clk_parent_name = of_clk_get_parent_name(pdev->dev.of_node, 0);
 
+	snprintf(prescaler_clk_name, sizeof(prescaler_clk_name), "prescaler-%s", pdev->name);
 	data->clk_prescaler = clk_hw_register_divider(
-				&pdev->dev, "prescaler", clk_parent_name, 0,
+				&pdev->dev, prescaler_clk_name, clk_parent_name, 0,
 				data->base + ASPEED_REG_CLOCK_CONTROL,
 				17, 15, 0, &data->clk_lock);
 	if (IS_ERR(data->clk_prescaler))
 		return PTR_ERR(data->clk_prescaler);
 
+	snprintf(scaler_clk_name, sizeof(scaler_clk_name), "scaler-%s", pdev->name);
 	/*
 	 * Register ADC clock scaler downstream from the prescaler. Allow rate
 	 * setting to adjust the prescaler as well.
 	 */
 	data->clk_scaler = clk_hw_register_divider(
-				&pdev->dev, "scaler", "prescaler",
+				&pdev->dev, scaler_clk_name, prescaler_clk_name,
 				CLK_SET_RATE_PARENT,
 				data->base + ASPEED_REG_CLOCK_CONTROL,
 				0, 10, 0, &data->clk_lock);
@@ -213,7 +246,7 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 		goto scaler_error;
 	}
 
-	data->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	data->rst = devm_reset_control_get_shared(&pdev->dev, NULL);
 	if (IS_ERR(data->rst)) {
 		dev_err(&pdev->dev,
 			"invalid or missing reset controller device tree entry");
@@ -223,11 +256,26 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 	reset_control_deassert(data->rst);
 
 	model_data = of_device_get_match_data(&pdev->dev);
+	if (!of_property_read_u32(pdev->dev.of_node, "ref_voltage", (u32 *)&model_data->vref_voltage)) {
+		if (model_data->vref_voltage == 2500)
+			eng_ctrl = REF_VLOTAGE_2500mV;
+		else if (model_data->vref_voltage == 1200)
+			eng_ctrl = REF_VLOTAGE_1200mV;
+		else if ((model_data->vref_voltage >= 1550) && (model_data->vref_voltage <= 2700))
+			eng_ctrl = REF_VLOTAGE_1550mV;
+		else if ((model_data->vref_voltage >= 900) && (model_data->vref_voltage <= 1650))
+			eng_ctrl = REF_VLOTAGE_900mV;
+		else {
+			printk("error ref voltage %d \n", model_data->vref_voltage);
+			eng_ctrl = 0;
+		}
+	} else
+		eng_ctrl = 0;
 
 	if (model_data->wait_init_sequence) {
 		/* Enable engine in normal mode. */
-		writel(ASPEED_OPERATION_MODE_NORMAL | ASPEED_ENGINE_ENABLE,
-		       data->base + ASPEED_REG_ENGINE_CONTROL);
+		eng_ctrl |= ASPEED_OPERATION_MODE_NORMAL | ASPEED_ENGINE_ENABLE;
+		writel(eng_ctrl, data->base + ASPEED_REG_ENGINE_CONTROL);
 
 		/* Wait for initial sequence complete. */
 		ret = readl_poll_timeout(data->base + ASPEED_REG_ENGINE_CONTROL,
@@ -240,12 +288,26 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 			goto poll_timeout_error;
 	}
 
+	// do compensating calculation use ch 0
+	writel(eng_ctrl | ASPEED_OPERATION_MODE_NORMAL | 
+			ASPEED_ENGINE_ENABLE | ASPEED_AUTOPENSATING, data->base + ASPEED_REG_ENGINE_CONTROL);
+
+	writel(eng_ctrl | ASPEED_OPERATION_MODE_NORMAL | BIT(16) |
+			ASPEED_ENGINE_ENABLE | ASPEED_AUTOPENSATING, data->base + ASPEED_REG_ENGINE_CONTROL);
+	mdelay(1);
+
+	data->cv = 0x200 - (readl(data->base + 0x10) & GENMASK(9, 0));
+
+	writel(eng_ctrl | ASPEED_OPERATION_MODE_NORMAL | 
+			ASPEED_ENGINE_ENABLE | ASPEED_AUTOPENSATING, data->base + ASPEED_REG_ENGINE_CONTROL);
+	printk(KERN_INFO "aspeed_adc: cv %d \n", data->cv);	
+
 	/* Start all channels in normal mode. */
 	ret = clk_prepare_enable(data->clk_scaler->clk);
 	if (ret)
 		goto clk_enable_error;
 
-	adc_engine_control_reg_val = GENMASK(31, 16) |
+	adc_engine_control_reg_val = eng_ctrl | GENMASK(31, 16) |
 		ASPEED_OPERATION_MODE_NORMAL | ASPEED_ENGINE_ENABLE;
 	writel(adc_engine_control_reg_val,
 		data->base + ASPEED_REG_ENGINE_CONTROL);
@@ -254,8 +316,8 @@ static int aspeed_adc_probe(struct platform_device *pdev)
 	indio_dev->name = model_data->model_name;
 	indio_dev->info = &aspeed_adc_iio_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
-	indio_dev->channels = aspeed_adc_iio_channels;
-	indio_dev->num_channels = ARRAY_SIZE(aspeed_adc_iio_channels);
+	indio_dev->channels = model_data->channels;
+	indio_dev->num_channels = model_data->num_channels;
 
 	ret = iio_device_register(indio_dev);
 	if (ret)
@@ -298,6 +360,8 @@ static const struct aspeed_adc_model_data ast2400_model_data = {
 	.vref_voltage = 2500, // mV
 	.min_sampling_rate = 10000,
 	.max_sampling_rate = 500000,
+	.channels = aspeed_adc_iio_channels,
+	.num_channels = 16,
 };
 
 static const struct aspeed_adc_model_data ast2500_model_data = {
@@ -306,11 +370,24 @@ static const struct aspeed_adc_model_data ast2500_model_data = {
 	.min_sampling_rate = 1,
 	.max_sampling_rate = 1000000,
 	.wait_init_sequence = true,
+	.channels = aspeed_adc_iio_channels,
+	.num_channels = 16,
+};
+
+static const struct aspeed_adc_model_data ast2600_model_data = {
+	.model_name = "ast2600-adc",
+	.vref_voltage = 1800, // mV --> can be 1.2v or 2.5 or ext 1.55~2.7v, 0.9v ~1.65v
+	.min_sampling_rate = 1,
+	.max_sampling_rate = 1000000,
+	.wait_init_sequence = true,
+	.channels = ast2600_adc_iio_channels,
+	.num_channels = 8,
 };
 
 static const struct of_device_id aspeed_adc_matches[] = {
 	{ .compatible = "aspeed,ast2400-adc", .data = &ast2400_model_data },
 	{ .compatible = "aspeed,ast2500-adc", .data = &ast2500_model_data },
+	{ .compatible = "aspeed,ast2600-adc", .data = &ast2600_model_data },
 	{},
 };
 MODULE_DEVICE_TABLE(of, aspeed_adc_matches);
@@ -327,5 +404,5 @@ static struct platform_driver aspeed_adc_driver = {
 module_platform_driver(aspeed_adc_driver);
 
 MODULE_AUTHOR("Rick Altherr <raltherr@google.com>");
-MODULE_DESCRIPTION("Aspeed AST2400/2500 ADC Driver");
+MODULE_DESCRIPTION("Aspeed AST2400/2500/2600 ADC Driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index aadaea0..8fc5eff 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -85,6 +85,13 @@ config SPI_ARMADA_3700
 	  This enables support for the SPI controller present on the
 	  Marvell Armada 3700 SoCs.
 
+config SPI_ASPEED
+	tristate "ASPEED SPI Controller"
+	depends on ARCH_ASPEED
+	help
+	  This enables support for the SPI controller present on the
+	  ASPEED SoCs.
+
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on ARCH_AT91 || COMPILE_TEST
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6fea582..bb99f40 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_SPI_SPIDEV)		+= spidev.o
 obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
 
 # SPI master controller drivers (bus)
+obj-$(CONFIG_SPI_ASPEED)		+= spi-aspeed.o
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
 obj-$(CONFIG_SPI_AR934X)		+= spi-ar934x.o
 obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
diff --git a/drivers/spi/spi-aspeed.c b/drivers/spi/spi-aspeed.c
new file mode 100644
index 0000000..d470a6c
--- /dev/null
+++ b/drivers/spi/spi-aspeed.c
@@ -0,0 +1,515 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ASPEED SPI Controller Driver
+ *
+ * Copyright 2019-present Facebook. All Rights Reserved.
+ *
+ * Borrowed some code from drivers/mtd/spi-nor/aspeed-smc.c.
+ *
+ * Based on Ryan Chen's work in 2012:
+ * Copyright (C) 2012-2020 ASPEED Technology Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+#define ASPEED_SPI_DRIVER		"aspeed-spi"
+#define ASPEED_SPI_CS_NUM		2
+#define ASPEED_SUPP_MODES		(SPI_CPOL | SPI_CPHA | SPI_CS_HIGH)
+
+/*
+ * Register definitions.
+ */
+#define ASPEED_CFG_REG			0x00
+#define ASPEED_CE_CTRL_REG		0x04
+#define ASPEED_CTRL_REG_CE0		0x10
+#define ASPEED_CTRL_REG_CE1		0x14
+#define ASPEED_ADDR_RANGE_REG_CE0	0x30
+#define ASPEED_ADDR_RANGE_REG_CE1	0x34
+
+/*
+ * Fields in SPI Flash Configuration Register SPIR00.
+ */
+#define ASPEED_CFG_ENABLE_WR_CE0	BIT(16)
+#define ASPEED_CFG_ENABLE_WR_CE1	BIT(17)
+
+/*
+ * Fields in SPI CE Control Register SPIR04.
+ */
+#define ASPEED_CTRL_DIV2_TIMING_CE0	BIT(8)
+#define ASPEED_CTRL_DIV2_TIMING_CE1	BIT(9)
+
+/*
+ * Fields in CE# Control register SPIR10/SPIR14.
+ */
+#define ASPEED_CTRL_NORMAL_RD_MODE	0
+#define ASPEED_CTRL_RD_CMD_MODE		1
+#define ASPEED_CTRL_WR_CMD_MODE		2
+#define ASPEED_CTRL_USER_MODE		3
+#define ASPEED_CTRL_STOP_ACTIVE		BIT(2)
+#define ASPEED_CTRL_CLK_MODE_3		BIT(4)
+#define ASPEED_CTRL_CLK_DIV4_MODE	BIT(13)
+#define ASPEED_CTRL_CLK_DIV_MAX		16
+#define ASPEED_CTRL_CLK_DIV_MASK	(0xF << 8)
+#define ASPEED_CTRL_CLK_DIV(d)		(((d) & 0xF) << 8)
+#define ASPEED2600_CTRL_CLK_DIV_MASK    ((0xF << 24) | (0xF << 8))
+#define ASPEED2600_CTRL_CLK_DIV(d)      (((d) & 0xF) << 8) | (((d) & 0xF0) << 20)
+
+/*
+ * AST2520/AST2500
+ * The Segment Register uses a 8MB unit to encode the start address
+ * and the end address of the mapping window of a flash SPI slave :
+ *
+ *        | byte 1 | byte 2 | byte 3 | byte 4 |
+ *        +--------+--------+--------+--------+
+ *        |  end   |  start |   0    |   0    |
+ */
+#define ASPEED_2500_SEGMENT_ADDR_START(_v)		((((_v) >> 16) & 0xFF) << 23)
+#define ASPEED_2500_SEGMENT_ADDR_END(_v)		((((_v) >> 24) & 0xFF) << 23)
+
+/*
+ * AST2620/AST2600
+ * The Segment Register uses a 1MB unit to encode the start address
+ * and the end address of the mapping window of a flash SPI slave :
+ *
+ *   bit: |  31-24  |  23-16  |  15-8     |  7-0      |
+ *        | byte 1  | byte 2  |  byte 3   |  byte 4   |
+ *        +---------+---------+-----------+-----------+
+ *        | end msb | end lsb | start msb | start lsb |
+ */
+#define ASPEED_2600_SEGMENT_ADDR_START(_v)		((_v) & 0x0FF00000)
+#define ASPEED_2600_SEGMENT_ADDR_END(_v)		(((_v) << 16) & 0x0FF00000)
+
+// CE0 gets 128MB CE0/CE1 get 64MB each by default
+#define AST2600_START_OFFSET(cs)       (cs == 0 ? 0x0000000 : \
+                                                  (0x8000000 + (cs - 1)*0x4000000))
+#define AST2600_END_OFFSET(cs)         (cs == 0 ? 0x8000000 : \
+                                                  (0x8000000 + (cs)*0x4000000))
+#define AST2600_SEGMENT_ADDR_VALUE(start, end) \
+	(((start & 0x0FF00000) >> 16) | (((end) - 1) & 0x0FF00000))
+
+struct aspeed_spi_priv {
+	void __iomem *reg_base;
+	struct spi_master *master;
+	struct device *dev;
+	bool aspeed_g6;
+	unsigned long ahb_clk_freq;
+
+	/*
+	 * Slave device addresses.
+	 */
+	void __iomem *slave_base;
+	u32 slave_mem_size;
+	struct {
+		void __iomem *start;
+		u32 size;
+	} slave_buf[ASPEED_SPI_CS_NUM];
+};
+
+static struct {
+	u32 ctrl_reg;
+	u32 addr_range_reg;
+	u32 enable_write;
+	u32 div2_mode;
+} cs_reg_map[ASPEED_SPI_CS_NUM] = {
+	[0] = {	/* chip select #0 */
+		.ctrl_reg = ASPEED_CTRL_REG_CE0,
+		.addr_range_reg = ASPEED_ADDR_RANGE_REG_CE0,
+		.enable_write = ASPEED_CFG_ENABLE_WR_CE0,
+		.div2_mode = ASPEED_CTRL_DIV2_TIMING_CE0,
+	},
+	[1] = {	/* chip select #1 */
+		.ctrl_reg = ASPEED_CTRL_REG_CE1,
+		.addr_range_reg = ASPEED_ADDR_RANGE_REG_CE1,
+		.enable_write = ASPEED_CFG_ENABLE_WR_CE1,
+		.div2_mode = ASPEED_CTRL_DIV2_TIMING_CE1,
+	},
+};
+
+static void aspeed_reg_write(struct aspeed_spi_priv *priv, u32 val, u32 reg)
+{
+	writel(val, priv->reg_base + reg);
+}
+
+static u32 aspeed_reg_read(struct aspeed_spi_priv *priv, u32 reg)
+{
+	return readl(priv->reg_base + reg);
+}
+
+static void aspeed_activate_cs(struct aspeed_spi_priv *priv, u8 cs)
+{
+	u32 ctrl_reg = cs_reg_map[cs].ctrl_reg;
+	u32 val = aspeed_reg_read(priv, ctrl_reg);
+
+	val &= ~ASPEED_CTRL_STOP_ACTIVE;
+	aspeed_reg_write(priv, val, ctrl_reg);
+}
+
+static void aspeed_deactivate_cs(struct aspeed_spi_priv *priv, u8 cs)
+{
+	u32 ctrl_reg = cs_reg_map[cs].ctrl_reg;
+	u32 val = aspeed_reg_read(priv, ctrl_reg);
+
+	val |= ASPEED_CTRL_STOP_ACTIVE;
+	aspeed_reg_write(priv, val, ctrl_reg);
+}
+
+static void aspeed2600_set_default_range(struct aspeed_spi_priv *priv,
+				        struct resource *res, u16 num_cs)
+{
+	u16 cs;
+	u32 start_offset;
+
+	for (cs = 0; cs < num_cs; cs++) {
+              u32 addr_range_reg = cs_reg_map[cs].addr_range_reg;
+              u32 val = aspeed_reg_read(priv, addr_range_reg);
+
+              val = AST2600_SEGMENT_ADDR_VALUE(res->start + AST2600_START_OFFSET(cs),
+                    res->start + AST2600_END_OFFSET(cs));
+              aspeed_reg_write(priv, val, addr_range_reg);
+	}
+}
+
+static bool aspeed_check_set_div2(struct aspeed_spi_priv *priv,
+				  u8 cs, u32 spi_max_freq)
+{
+	u32 div, val;
+
+	div = priv->ahb_clk_freq / spi_max_freq;
+	if (div <= ASPEED_CTRL_CLK_DIV_MAX)
+		return false;
+
+	val = aspeed_reg_read(priv, ASPEED_CE_CTRL_REG);
+	val |= cs_reg_map[cs].div2_mode;
+	aspeed_reg_write(priv, val, ASPEED_CE_CTRL_REG);
+	return true;
+}
+
+/*
+ * Calculate spi clock frequency divisor. Refer to AST2500 datasheet,
+ * Chapter 14, CE# Control Register, bit 11:8 for details.
+ */
+static u32 aspeed_spi_clk_div(unsigned long ahb_clk_freq,
+			      u32 spi_max_freq)
+{
+	unsigned long i;
+	u32 div_val = 0;
+	static const u32 div_map[ASPEED_CTRL_CLK_DIV_MAX] = {
+		15, 7, 14, 6, 13, 5, 12, 4,
+		11, 3, 10, 2, 9, 1, 8, 0,
+	};
+
+	for (i = 1; i <= ASPEED_CTRL_CLK_DIV_MAX; i++) {
+		if ((spi_max_freq * i) >= ahb_clk_freq) {
+			div_val = div_map[i - 1];
+			break;
+		}
+	}
+
+	return div_val;
+}
+
+/*
+ * Calculate spi clock frequency divisor. Refer to AST2600 datasheet,
+ * Chapter 15, CE# control registers SPIR10/14/18, bit 27:24, 11:8.
+ */
+static u32 aspeed2600_spi_clk_div(unsigned long ahb_clk_freq,
+			      u32 spi_max_freq)
+{
+	unsigned long i, j;
+	u32 div_val = 0;
+	u8 base_div = 0;
+	bool done = 0;
+
+	static const u32 div_map[ASPEED_CTRL_CLK_DIV_MAX] = {
+		15, 7, 14, 6, 13, 5, 12, 4,
+		11, 3, 10, 2, 9, 1, 8, 0,
+	};
+
+	for (j = 0; j < 0xF; j++) {
+		for (i = 1; i <= ASPEED_CTRL_CLK_DIV_MAX; i++) {
+			base_div = j*16;
+			if ((spi_max_freq * (i+base_div)) >= ahb_clk_freq) {
+				div_val = (j << 4) | div_map[i - 1];
+				done = 1;
+				break;
+			}
+		}
+		if (done)
+			break;
+	}
+
+	return div_val;
+}
+
+static int
+aspeed_spi_setup(struct spi_device *slave)
+{
+	u8 cs = slave->chip_select;
+	u32 div, val, ctrl_reg, freq;
+	struct aspeed_spi_priv *priv = spi_master_get_devdata(slave->master);
+
+	if (cs == 0 && slave->mode & SPI_CS_HIGH) {
+		dev_err(&slave->dev,
+			"chip_select %u cannot be active-high\n", cs);
+		return -EINVAL;
+	}
+
+	/*
+	 * Update SPIR00 (Configuration Register).
+	 */
+	val = aspeed_reg_read(priv, ASPEED_CFG_REG);
+	val |= cs_reg_map[cs].enable_write;
+	aspeed_reg_write(priv, val, ASPEED_CFG_REG);
+
+	/*
+	 * Update CE# Control Register.
+	 */
+	ctrl_reg = cs_reg_map[cs].ctrl_reg;
+	val = aspeed_reg_read(priv, ctrl_reg);
+	val &= ~ASPEED_CTRL_CLK_MODE_3; /* clock mode 3 is not supported */
+	if (slave->max_speed_hz != 0) {
+		freq = slave->max_speed_hz;
+                if (priv->aspeed_g6) {
+			val &= ~ASPEED2600_CTRL_CLK_DIV_MASK;
+			div = aspeed2600_spi_clk_div(priv->ahb_clk_freq, freq);
+			val |= ASPEED2600_CTRL_CLK_DIV(div);
+                } else {
+			val &= ~ASPEED_CTRL_CLK_DIV_MASK;
+
+			if (aspeed_check_set_div2(priv, cs, freq)) {
+				// SPI clock divided by 4
+				val |= ASPEED_CTRL_CLK_DIV4_MODE;
+				freq = freq >> 2;
+			}
+			val |= ASPEED_CTRL_CLK_DIV(div);
+			div = aspeed_spi_clk_div(priv->ahb_clk_freq, freq);
+                }
+	}
+	aspeed_reg_write(priv, val, ctrl_reg);
+
+	return 0;
+}
+
+static void aspeed_spi_set_cs(struct spi_device *slave, bool level)
+{
+	u8 cs = slave->chip_select;
+	struct aspeed_spi_priv *priv = spi_master_get_devdata(slave->master);
+
+	if (level)
+		aspeed_deactivate_cs(priv, cs);
+	else
+		aspeed_activate_cs(priv, cs);
+}
+
+static void aspeed_spi_do_xfer(struct aspeed_spi_priv *priv,
+			       struct spi_transfer *xfer, u32 cs)
+{
+	unsigned int i;
+	u8 *rx_buf = xfer->rx_buf;
+	const u8 *tx_buf = xfer->tx_buf;
+	void *slave_buf = priv->slave_buf[cs].start;
+
+	if (tx_buf != NULL) {
+		for (i = 0; i < xfer->len; i++)
+			writeb(tx_buf[i], slave_buf);
+	}
+
+	if (rx_buf != NULL) {
+		for (i = 0; i < xfer->len; i++)
+			rx_buf[i] = readb(slave_buf);
+	}
+}
+
+static int aspeed_spi_xfer_one(struct spi_master *master,
+			       struct spi_device *slave,
+			       struct spi_transfer *xfer)
+{
+	struct aspeed_spi_priv *priv = spi_master_get_devdata(master);
+	u8 cs = slave->chip_select;
+
+	aspeed_spi_do_xfer(priv, xfer, cs);
+
+	return 0;
+}
+
+static void aspeed_spi_init_hw(struct aspeed_spi_priv *priv, u16 num_cs)
+{
+	u16 cs;
+
+	for (cs = 0; cs < num_cs; cs++) {
+		u32 ctrl_reg = cs_reg_map[cs].ctrl_reg;
+		u32 val = aspeed_reg_read(priv, ctrl_reg);
+
+		val |= (ASPEED_CTRL_STOP_ACTIVE | ASPEED_CTRL_USER_MODE);
+		aspeed_reg_write(priv, val, ctrl_reg);
+	}
+}
+
+static int aspeed_spi_init_slave_buf(struct aspeed_spi_priv *priv,
+				     struct resource *res, u16 num_cs)
+{
+	u16 cs;
+
+	for (cs = 0; cs < num_cs; cs++) {
+		u32 val, start, end, size, offset;
+
+		val = aspeed_reg_read(priv, cs_reg_map[cs].addr_range_reg);
+		if (priv->aspeed_g6) {
+			start = res->start + ASPEED_2600_SEGMENT_ADDR_START(val);
+			end = res->start + ASPEED_2600_SEGMENT_ADDR_END(val);
+		} else {
+			start = ASPEED_2500_SEGMENT_ADDR_START(val);
+			end = ASPEED_2500_SEGMENT_ADDR_START(val);
+		}
+		size = end - start;
+
+		if (start < res->start) {
+			dev_err(priv->dev,
+				"cs %u: invalid start address %#lx\n",
+				cs, (unsigned long)start);
+			return -EINVAL;
+		}
+
+		offset = start - res->start;
+		if (offset + size > priv->slave_mem_size) {
+			dev_err(priv->dev,
+				"cs %u: invalid address range (%#lx - %#lx)\n",
+				cs, (unsigned long)start,
+				(unsigned long)(start + size));
+				return -EINVAL;
+		}
+
+		priv->slave_buf[cs].start = priv->slave_base + offset;
+		priv->slave_buf[cs].size = size;
+	}
+
+	return 0;
+}
+
+static int aspeed_spi_probe(struct platform_device *pdev)
+{
+	u32 slave_mem_size;
+	struct resource *res;
+	void __iomem *reg_base, *slave_base;
+	struct clk *clk;
+	struct aspeed_spi_priv *priv;
+	struct spi_master *master;
+	int error;
+	unsigned long ahb_clk_freq;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	reg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(reg_base))
+		return PTR_ERR(reg_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	slave_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(slave_base))
+		return PTR_ERR(slave_base);
+	slave_mem_size = resource_size(res);
+
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+	ahb_clk_freq = clk_get_rate(clk);
+	devm_clk_put(&pdev->dev, clk);
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct aspeed_spi_priv));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi_master\n");
+		return -ENOMEM;
+	}
+	master->flags = SPI_MASTER_HALF_DUPLEX;
+	master->mode_bits = ASPEED_SUPP_MODES;
+	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
+	master->dev.of_node = pdev->dev.of_node;
+	master->num_chipselect = ASPEED_SPI_CS_NUM;
+	master->setup = aspeed_spi_setup;
+	master->set_cs = aspeed_spi_set_cs;
+	master->transfer_one = aspeed_spi_xfer_one;
+
+	priv = spi_master_get_devdata(master);
+	priv->dev = &pdev->dev;
+	priv->master = master;
+	priv->reg_base = reg_base;
+	priv->slave_base = slave_base;
+	priv->slave_mem_size = slave_mem_size;
+	priv->ahb_clk_freq = ahb_clk_freq;
+	platform_set_drvdata(pdev, priv);
+	if (of_device_is_compatible(master->dev.of_node, "aspeed,ast2600-spi-master")) {
+		priv->aspeed_g6 = true;
+		// AST2600: CE0 gets 128MB CE0/CE1 get 64MB each by default
+		aspeed2600_set_default_range(priv, res, master->num_chipselect);
+	}
+
+	error = aspeed_spi_init_slave_buf(priv, res, master->num_chipselect);
+	if (error != 0)
+		goto err_exit;
+
+	aspeed_spi_init_hw(priv, master->num_chipselect);
+
+	/* Register our spi controller */
+	error = devm_spi_register_master(&pdev->dev, master);
+	if (error) {
+		dev_err(&pdev->dev, "failed to register SPI master\n");
+		goto err_exit;
+	}
+
+	return 0;
+
+err_exit:
+	spi_master_put(master);
+	dev_err(&pdev->dev, "%s returned error %d\n", __func__, error);
+	return error;
+}
+
+static int
+aspeed_spi_remove(struct platform_device *pdev)
+{
+	struct aspeed_spi_priv *priv = platform_get_drvdata(pdev);
+
+	if (priv == NULL)
+		return -1;
+
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(priv->master);
+	return 0;
+}
+
+static const struct of_device_id aspeed_spi_of_match[] = {
+	{ .compatible = "aspeed,ast2500-spi-master", },
+	{ .compatible = "aspeed,ast2600-spi-master", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, aspeed_spi_of_match);
+
+static struct platform_driver aspeed_spi_driver = {
+	.probe = aspeed_spi_probe,
+	.remove = aspeed_spi_remove,
+	.driver = {
+		.name = ASPEED_SPI_DRIVER,
+		.of_match_table = aspeed_spi_of_match,
+	},
+};
+module_platform_driver(aspeed_spi_driver);
+
+MODULE_AUTHOR("Tao Ren <taoren@fb.com>");
+MODULE_DESCRIPTION("ASPEED SPI Host Driver");
+MODULE_LICENSE("GPL");
+
-- 
2.7.4

